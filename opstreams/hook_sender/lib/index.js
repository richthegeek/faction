// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  module.exports = function(stream, config, row) {
    var Account_Model, Cache, Fact_Model, async, lib, models, path, request;
    request = require('request');
    async = require('async');
    Cache = require('shared-cache');
    path = require('path');
    lib = path.resolve(__dirname, '../../../lib');
    models = lib + '/models/';
    Account_Model = require(models + 'account');
    Fact_Model = require(models + 'fact_deferred');
    config.models = {
      account: Account_Model
    };
    return function(row, callback) {
      var fns, self,
        _this = this;
      self = this;
      fns = [];
      if (this.accountModel == null) {
        fns.push(function(next) {
          return new Account_Model(function() {
            self.accountModel = this;
            return this.load({
              _id: stream.db.databaseName.replace(/^faction_account_/, '')
            }, next);
          });
        });
      }
      fns.push(function() {
        var account, next;
        next = Array.prototype.pop.call(arguments);
        account = self.accountModel;
        if (self.cache == null) {
          self.cache = Cache.create('hooks-' + account.data._id, true, function(key, next) {
            return stream.db.collection('hooks').find().toArray(next);
          });
        }
        return self.cache.get(function(err, hooks) {
          var hook, _i, _len;
          for (_i = 0, _len = hooks.length; _i < _len; _i++) {
            hook = hooks[_i];
            if (hook.fact_type === row.fact_type && hook.hook_id === row.hook_id) {
              return next(null, account, hook);
            }
          }
          return next('Unknown hook id');
        });
      });
      fns.push(function() {
        var account, hook, next, skip, _i;
        account = arguments[0], hook = arguments[1], skip = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), next = arguments[_i++];
        if (hook.mode === 'snapshot') {
          return new Fact_Model(account, row.fact_type, function() {
            var _ref;
            hook["with"] = [].concat.call([], (_ref = hook["with"]) != null ? _ref : []);
            if (hook.path == null) {
              hook.path = 'this';
            }
            if ('this' !== hook.path.substring(0, 4)) {
              hook.path = 'this.' + hook.path;
            }
            self.table = this.table;
            return this.load({
              _id: row.fact_id
            }, function(err, found) {
              var _this = this;
              if (err || !found) {
                return callback('Fact not found');
              }
              return async.map(hook["with"], this.data.get.bind(this.data), function() {
                return _this.data["eval"](hook.path, function(err, result) {
                  return next(err, account, hook, JSON.parse(JSON.stringify(result)));
                });
              });
            });
          });
        } else {
          return next(err, account, hook, row.data);
        }
      });
      return async.waterfall(fns, function(err, account, hook, fact) {
        var cb, expired, file, hookService;
        if (err) {
          return callback(err);
        }
        if (!fact) {
          return callback();
        }
        expired = hook.mode !== 'snapshot' && row.data._updated !== fact._updated;
        if (expired) {
          console.log('Expired');
          return next();
        }
        cb = function(err, res, body) {
          return callback(null, {
            hook_id: row.hook_id,
            fact_type: row.fact_type,
            fact_id: fact._id,
            status: res.statusCode,
            body: body,
            time: new Date
          });
        };
        if (hook.type == null) {
          hook.type = 'url';
        }
        file = path.resolve(__dirname, './types') + '/' + hook.type;
        hookService = require(file);
        try {
          return hookService.exec(hook, fact, function(err, result) {
            if (err) {
              console.log(err);
              console.log(JSON.stringify(err));
              throw err;
            }
            console.log('Callback', result);
            return;
            return cb(err, result);
          });
        } catch (_error) {
          err = _error;
          console.log('Shit code alert');
          console.log(err);
        }
      });
    };
  };

}).call(this);
