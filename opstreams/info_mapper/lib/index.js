// Generated by CoffeeScript 1.6.3
module.exports = function(stream, config) {
  var Account_Model, Cache, Fact_Model, InfoMapping_Model, async, lib, models, path, _mappings, _settings;
  async = require('async');
  Cache = require('shared-cache');
  path = require('path');
  lib = path.resolve(__dirname, '../../../lib');
  models = lib + '/models/';
  Account_Model = require(models + 'account');
  InfoMapping_Model = require(models + 'infomapping');
  Fact_Model = require(models + 'fact');
  config.models = {
    account: Account_Model,
    infomapping: InfoMapping_Model,
    fact: Fact_Model
  };
  _mappings = Cache.create('info-mappings-' + this.account, true, function(key, next) {
    return stream.db.collection('info_mappings').find().toArray(next);
  });
  _settings = Cache.create('fact-settings-' + this.account, true, function(key, next) {
    return stream.db.collection('fact_settings').find().toArray(next);
  });
  return function(row, callback) {
    var fn, markForeignFacts, mergeFacts, self,
      _this = this;
    self = this;
    config.time = row._id.getTimestamp() || new Date;
    mergeFacts = require('./merge_facts')(stream, config, row);
    markForeignFacts = require('./mark_foreign_facts')(stream, config, row);
    fn = function(next) {
      return next();
    };
    if (this.accountModel == null) {
      fn = function(next) {
        return new Account_Model(function() {
          self.accountModel = this;
          return this.load({
            _id: stream.db.databaseName.replace(/^faction_account_/, '')
          }, next);
        });
      };
    }
    /*
    		A sample mapping:
    			info_type: 'visit',
    			fact_type: 'sessions',
    			fact_identifier: 'info.sid',
    			fields:
    				uid: 'info.uid'
    				visits:
    					url: 'info.url',
    					time: 'new Date'
    
    		A sample fact setting:
    			fact_type: 'sessions'
    			field_modes:
    				actions: 'all'
    				score:
    					eval: "
    						async();
    						http.request("http://trakapo.com/score", {})
    
    					"
    			foreign_keys:
    				user:
    					fact_type: 'users'
    					has: 'one'
    					query:
    						_id: 'fact.uid'
    
    		With this we need to:
    		 - find the fact_identifier in the facts_sessions collection
    		 - load the fact settings for the "sessions" fact (cache!)
    		 - merge the new info into the existing fact
    		 - save, ping any FKs as updated.
    */

    return fn(function() {
      var account;
      account = _this.accountModel;
      return _mappings.get(function(err, mappings) {
        return _settings.get(function(err, settings) {
          var combineMappings, parseMappings;
          parseMappings = function(mapping, next) {
            var query;
            if (mapping.info_type !== row._type) {
              return next();
            }
            query = {
              _id: InfoMapping_Model["eval"](mapping.fact_identifier, {
                info: row
              })
            };
            return new Fact_Model(account, mapping.fact_type, function() {
              var model;
              model = this;
              return this.load(query, true, function(err, fact) {
                if (fact == null) {
                  fact = {};
                }
                if (err) {
                  return next(err);
                }
                delete row._type;
                if (Object.prototype.toString.call(row._id) === '[object Object]') {
                  delete row._id;
                }
                return InfoMapping_Model.parseObject(mapping.fields, {
                  info: row,
                  fact: fact
                }, function(obj) {
                  obj._id = query._id;
                  return next(null, {
                    model: model,
                    fact: fact,
                    mapping: mapping,
                    info: obj
                  });
                });
              });
            });
          };
          combineMappings = function(info, next) {
            var setting;
            setting = info.fact.getSettings();
            return info.model["import"](mergeFacts(setting, info.fact, info.info), function() {
              return this.addShim(function(err, fact) {
                return info.model.table.save(fact, function(err) {
                  var field, fk, iter_wrap, list;
                  list = (function() {
                    var _ref, _results;
                    _ref = setting.foreign_keys || {};
                    _results = [];
                    for (field in _ref) {
                      fk = _ref[field];
                      _results.push(fk);
                    }
                    return _results;
                  })();
                  iter_wrap = function(fk, next) {
                    return markForeignFacts(fk, fact, next);
                  };
                  return async.map(list, iter_wrap, function(err, updates) {
                    updates = updates.filter(function(v) {
                      return v && v.length > 0;
                    });
                    updates.push({
                      id: fact._id,
                      type: info.mapping.fact_type,
                      time: +(new Date)
                    });
                    console.log('Nearly', updates);
                    return;
                    return next(err, updates);
                  });
                });
              });
            });
          };
          return async.map(mappings, parseMappings, function(err, result) {
            result = [].concat.apply([], result).filter(function(r) {
              return !!r;
            });
            return async.map(result, combineMappings, function() {
              return console.log('COMPLETE', arguments);
            });
          });
        });
      });
    });
  };
};
