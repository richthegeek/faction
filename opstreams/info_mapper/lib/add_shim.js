// Generated by CoffeeScript 1.6.3
var __slice = [].slice;

module.exports = function(stream, config, row) {
  var async, bindFunctions, cache, evaluate, parseObject, _ref;
  cache = require('shared-cache');
  async = require('async');
  bindFunctions = require('./bind_functions')(stream, config, row);
  _ref = require('./eval')(stream, config, row), evaluate = _ref.evaluate, parseObject = _ref.parseObject;
  return function(data, account, db, table, type, callback) {
    var FKCache, loadFK, _settings,
      _this = this;
    FKCache = {};
    loadFK = function(properties, callback) {
      var next;
      if (FKCache[properties.key] != null) {
        return process.nextTick(function() {
          return callback(null, FKCache[properties.key]);
        });
      }
      next = function(err, data) {
        if (data) {
          FKCache[properties.key] = data;
        }
        return callback(err, data);
      };
      return parseObject(properties.query, {
        fact: data
      }, function(query) {
        return new config.models.fact(account, properties.fact_type, function() {
          if ((query._id != null) || properties.has === 'one') {
            return this.load(query, true, next);
          } else {
            return this.loadAll(query, true, next);
          }
        });
      });
    };
    _settings = cache.create('fact-settings-' + account.data._id, true, function(key, next) {
      return db.collection('fact_settings').find().toArray(next);
    });
    return _settings.get(function(err, allSettings) {
      var fk_arr, k, loadAutoFKs, set, settings, v, _base, _ref1;
      settings = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = allSettings.length; _i < _len; _i++) {
          set = allSettings[_i];
          if (set._id === type) {
            _results.push(set);
          }
        }
        return _results;
      })()).pop() || {};
      if (settings.foreign_keys == null) {
        settings.foreign_keys = {};
      }
      fk_arr = [];
      _ref1 = settings.foreign_keys;
      for (k in _ref1) {
        v = _ref1[k];
        settings.foreign_keys[k].key = k;
        if ((_base = settings.foreign_keys[k]).autoload == null) {
          _base.autoload = false;
        }
        fk_arr.push(settings.foreign_keys[k]);
      }
      bindFunctions(data);
      data.getSettings = function() {
        return settings;
      };
      data.get = function() {
        var args, callback, i, iter, result, _i,
          _this = this;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        console.log('GET', args);
        result = this;
        args = [].concat.apply([], args.map(function(arg) {
          return arg.split(/[\.\/]/);
        }));
        i = 0;
        iter = function(arg, next) {
          var extract, ii;
          i++;
          extract = function(obj, cb) {
            if (typeof obj === 'function') {
              return obj(cb);
            }
            return cb(null, (function() {
              var _ref2, _results;
              _ref2 = obj || {};
              _results = [];
              for (k in _ref2) {
                v = _ref2[k];
                _results.push(v);
              }
              return _results;
            })());
          };
          if (arg === '*') {
            return extract(result, function(err, res) {
              return next(null, result = res);
            });
          } else if (result[arg] != null) {
            if (typeof result[arg] === 'function') {
              return result[arg](function(err, res) {
                return next(null, result = res);
              });
            }
            return next(null, result = result[arg]);
          } else if (i === 1 && (settings.foreign_keys[arg] != null)) {
            return loadFK.call(_this, settings.foreign_keys[arg], function(err, res) {
              return next(err, result = res);
            });
          } else if (Array.isArray(result)) {
            ii = function(r, n) {
              return extract(r[arg], n);
            };
            return async.map(result, ii, function(err, res) {
              return next(err, result = [].concat.apply([], res));
            });
          }
        };
        return async.eachSeries(args, iter, function(err) {
          return callback(err, result);
        });
      };
      loadAutoFKs = function(fk, next) {
        if (fk.autoload !== true) {
          return next();
        }
        return loadFK(fk, function(err, row) {
          if (row) {
            data[fk.key] = row;
          }
          return next();
        });
      };
      return async.each(fk_arr, loadAutoFKs, function() {
        return callback(null, data);
      });
    });
  };
};
