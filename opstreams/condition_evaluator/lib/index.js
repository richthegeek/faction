// Generated by CoffeeScript 1.6.3
module.exports = function(stream, config, row) {
  var Account_Model, Cache, Fact_Model, account_name, async, bindFunctions, bindFunctionsPath, contextify, lib, models, path, _conditions, _hooks;
  async = require('async');
  contextify = require('contextify');
  Cache = require('shared-cache');
  path = require('path');
  lib = path.resolve(__dirname, '../../../lib');
  models = lib + '/models/';
  Account_Model = require(models + 'account');
  Fact_Model = require(models + 'fact');
  account_name = stream.db.databaseName.replace(/^faction_account_/, '');
  _conditions = Cache.create('fact-conditions-' + account_name, true, function(key, next) {
    return stream.db.collection('fact_conditions').find().toArray(next);
  });
  _hooks = Cache.create('hooks-' + account_name, true, function(key, next) {
    return stream.db.collection('hooks').find().toArray(next);
  });
  bindFunctionsPath = path.resolve(lib, '../opstreams/info_mapper/lib/bind_functions');
  bindFunctions = require(bindFunctionsPath)(stream, config, row);
  config.models = {
    account: Account_Model,
    fact: Fact_Model
  };
  return function(row, callback) {
    var fns, self,
      _this = this;
    self = this;
    fns = {};
    if (!row.type) {
      return callback();
    }
    fns.account = function(next) {
      if (self.accountModel) {
        return next(null, self.accountModel);
      }
      return new Account_Model(function() {
        self.accountModel = this;
        return this.load({
          _id: account_name
        }, next);
      });
    };
    fns.conditions = function(next) {
      return _conditions.get(next);
    };
    fns.fact = function(next) {
      return new Fact_Model(self.accountModel, row.type, function() {
        if (row.fact) {
          return this["import"](row.fact, function() {
            return next(null, this);
          });
        }
        return this.load({
          _id: row.id
        }, function() {
          return next(null, this);
        });
      });
    };
    return async.series(fns, function(err, results) {
      var code, condition, conditions, fact, result, sandbox, _i, _len;
      if (err || !results.fact) {
        return callback(err, null);
      }
      fact = results.fact;
      conditions = results.conditions.filter(function(cond) {
        return cond.fact_type === row.type;
      });
      code = "condition.result = condition.conditions.every(function(condition) {\n	try {\n		return eval(condition);\n	} catch(e) {\n		console.error(e);\n		return false;\n	}\n});";
      result = {};
      sandbox = {
        fact: bindFunctions(fact),
        condition: null,
        console: console
      };
      contextify(sandbox);
      for (_i = 0, _len = conditions.length; _i < _len; _i++) {
        condition = conditions[_i];
        sandbox.condition = condition;
        sandbox.run(code);
        result['_conditions.' + condition.condition_id] = !!sandbox.condition.result;
      }
      return fact.table.update({
        _id: row.id
      }, {
        $set: result
      }, function(err) {
        delete row.fact;
        row.result = result;
        row.time = +(new Date);
        return callback(err, row);
      });
    });
  };
};
