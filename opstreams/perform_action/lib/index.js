// Generated by CoffeeScript 1.6.3
var __slice = [].slice;

module.exports = function(stream, config, row) {
  var Account_Model, Action_Model, Cache, Fact_Model, async, bindFunctions, bindFunctionsPath, lib, models, path;
  async = require('async');
  Cache = require('shared-cache');
  path = require('path');
  lib = path.resolve(__dirname, '../../../lib');
  models = lib + '/models/';
  Account_Model = require(models + 'account');
  Action_Model = require(models + 'action');
  Fact_Model = require(models + 'fact');
  bindFunctionsPath = path.resolve(lib, '../opstreams/info_mapper/lib/bind_functions');
  bindFunctions = require(bindFunctionsPath)(stream, config, row);
  config.models = {
    account: Account_Model,
    fact: Fact_Model
  };
  return function(row, callback) {
    var fns, self,
      _this = this;
    self = this;
    fns = [];
    if (this.accountModel == null) {
      fns.push(function(next) {
        return new Account_Model(function() {
          self.accountModel = this;
          return this.load({
            _id: stream.db.databaseName.replace(/^faction_account_/, '')
          }, next);
        });
      });
    }
    fns.push(function() {
      var account, next;
      next = Array.prototype.pop.call(arguments);
      account = self.accountModel;
      if (self.cache == null) {
        self.cache = Cache.create('actions-' + account.data._id, true, function(key, next) {
          return stream.db.collection('actions').find().toArray(next);
        });
      }
      return self.cache.get(function(err, actions) {
        return next(err, account, actions);
      });
    });
    fns.push(function() {
      var account, actions, next, skip, _i;
      account = arguments[0], actions = arguments[1], skip = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), next = arguments[_i++];
      return new Fact_Model(account, row.type, function() {
        self.table = this.table;
        return this.load({
          _id: row.id
        }, function(err, fact) {
          return next(err, account, actions, fact);
        });
      });
    });
    return async.waterfall(fns, function(err, account, actions, fact) {
      var iterator;
      if (err) {
        return callback(err);
      }
      if (!fact) {
        return callback();
      }
      iterator = function(action, next) {
        if (action.fact_type !== fact.type) {
          return next();
        }
        return new Action_Model(account, function(err) {
          return this["import"](action, function() {
            action = this;
            return this.fact_run(fact, row.stage || 0, function(err, result, final_stage) {
              return next(null, {
                action_id: action.data.action_id,
                fact_type: action.data.fact_type,
                fact_id: row.id,
                time: new Date,
                result: [].concat(err || result),
                status: err && 'error' || 'ok',
                stage_from: Number(row.stage || 0),
                stage_to: final_stage
              });
            });
          });
        });
      };
      return modules.async.map(actions, iterator, function(err, rows) {
        return callback(null, rows);
      });
    });
  };
};
