// Generated by CoffeeScript 1.6.3
var __slice = [].slice;

module.exports = function(stream, config, row) {
  var Account_Model, Cache, Fact_Model, async, bindFunctions, bindFunctionsPath, contextify, lib, models, path;
  async = require('async');
  contextify = require('contextify');
  Cache = require('shared-cache');
  path = require('path');
  lib = path.resolve(__dirname, '../../../lib');
  models = lib + '/models/';
  Account_Model = require(models + 'account');
  Fact_Model = require(models + 'fact');
  bindFunctionsPath = path.resolve(lib, '../opstreams/info_mapper/lib/bind_functions');
  bindFunctions = require(bindFunctionsPath)(stream, config, row);
  config.models = {
    account: Account_Model,
    fact: Fact_Model
  };
  return function(row, callback) {
    var fns, self,
      _this = this;
    self = this;
    fns = [];
    if (this.accountModel == null) {
      fns.push(function(next) {
        return new Account_Model(function() {
          self.accountModel = this;
          return this.load({
            _id: stream.db.databaseName.replace(/^faction_account_/, '')
          }, next);
        });
      });
    }
    fns.push(function() {
      var account, next;
      next = Array.prototype.pop.call(arguments);
      account = self.accountModel;
      if (self.cache == null) {
        self.cache = Cache.create('conditions-' + account.data._id, true, function(key, next) {
          return stream.db.collection('conditions').find().toArray(next);
        });
      }
      return self.cache.get(function(err, conditions) {
        return next(err, account, conditions);
      });
    });
    fns.push(function() {
      var account, conditions, next, skip, _i;
      account = arguments[0], conditions = arguments[1], skip = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), next = arguments[_i++];
      return new Fact_Model(account, row.type, function() {
        self.table = this.table;
        return this.load({
          _id: row.id
        }, function(err, fact) {
          return next(err, account, conditions, fact);
        });
      });
    });
    return async.waterfall(fns, function(err, account, conditions, fact) {
      var code, condition, result, sandbox, _i, _len;
      if (err) {
        return callback(err);
      }
      if (!fact) {
        return callback();
      }
      code = "condition.result = condition.conditions.every(function(condition) {\n	try {\n		return eval(condition);\n	} catch(e) {\n		console.error(e);\n		return false;\n	}\n});";
      result = {};
      sandbox = {
        fact: bindFunctions(fact),
        condition: null,
        console: console
      };
      contextify(sandbox);
      for (_i = 0, _len = conditions.length; _i < _len; _i++) {
        condition = conditions[_i];
        if (!(condition.fact_type === row.type)) {
          continue;
        }
        sandbox.condition = condition;
        sandbox.run(code);
        result['_conditions.' + condition.condition_id] = !!sandbox.condition.result;
      }
      return self.table.update({
        _id: row.id
      }, {
        $set: result
      }, function(err) {
        return callback(err, {
          id: row.id,
          type: row.type,
          result: result,
          time: +(new Date)
        });
      });
    });
  };
};
