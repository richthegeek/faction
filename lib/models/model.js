// Generated by CoffeeScript 1.6.3
(function() {
  var Model;

  module.exports = Model = (function() {
    function Model(db, collection, callback) {
      var _this = this;
      mongodb.open(db, collection, config.mongo.host, config.mongo.port, function(err, db, table) {
        _this.db = db;
        _this.table = table;
        if (callback) {
          return callback.call(_this, _this, db, table);
        }
      });
    }

    Model.prototype._spawn = function(callback) {
      return new this.constructor(this.db, this.table, callback);
    };

    Model.prototype.setup = function() {
      return null;
    };

    Model.prototype["import"] = function(data, callback) {
      var k, v, _ref;
      this.data = this.data || {};
      _ref = data || {};
      for (k in _ref) {
        v = _ref[k];
        this.data[k] = v;
      }
      return callback.call(this, this.data);
    };

    Model.prototype["export"] = function() {
      return this.data;
    };

    Model["export"] = function(data) {
      return this.prototype["export"].call({
        data: data
      });
    };

    Model.prototype.toJSON = function() {
      return this["export"]();
    };

    Model.prototype.load = function(conditions, callback) {
      var _ref,
        _this = this;
      if ((conditions instanceof mongodb.ObjectID) || ((_ref = typeof conditions) === 'string' || _ref === 'number')) {
        conditions = {
          _id: conditions
        };
      }
      return this.table.findOne(conditions, function(err, row) {
        return _this["import"](row, function() {
          return callback.call(_this, err, row, conditions);
        });
      });
    };

    Model.prototype.paramsToQuery = function(params) {
      var name, query, value;
      query = {};
      for (name in params) {
        value = params[name];
        name = name.replace(/-/g, '_');
        query[name] = value;
      }
      return query;
    };

    Model.prototype.loadParams = function(params, callback) {
      return this.load(params.asQuery(), callback);
    };

    Model.prototype.loadPaginated = function(conditions, req, callback) {
      var skip, _ref, _ref1,
        _this = this;
      req.query.page = Number((_ref = req.query.page) != null ? _ref : 0);
      req.query.limit = Number((_ref1 = req.query.limit) != null ? _ref1 : 100);
      if (isNaN(req.query.page) || req.query.page < 0) {
        return callback('The page query parameter must be numeric and greater than 0');
      }
      if (isNaN(req.query.limit) || req.query.limit < 1) {
        return callback('The limit query parameter must be numeric and greater than 1');
      }
      skip = req.query.page * req.query.limit;
      return this.table.find(conditions, function(err, cursor) {
        if (err) {
          return callback(err);
        }
        return cursor.count(function(err, size) {
          var bits, key, param, sort, val, _i, _len, _ref2;
          sort = false;
          if (req.params.sort) {
            bits = req.params.sort.toString().split(',');
            sort = {};
            for (_i = 0, _len = bits.length; _i < _len; _i++) {
              param = bits[_i];
              if (param.substring(0, 1) === '-') {
                sort[param.slice(1)] = -1;
              } else {
                sort[param] = 1;
              }
            }
          }
          if (req.body.sort) {
            sort = {};
            _ref2 = req.body.sort;
            for (key in _ref2) {
              val = _ref2[key];
              sort[key] = (val === 'desc' && -1) || 1;
            }
          }
          if (sort !== false) {
            console.log('sorting', sort);
            cursor.sort(sort);
          }
          return cursor.skip(skip).limit(req.query.limit).toArray(function(err, items) {
            return new Grouped_Model(_this, items, function() {
              var response;
              response = {
                page: req.query.page,
                limit: req.query.limit,
                totalItems: size,
                totalPages: Math.ceil(size / req.query.limit),
                nextPage: null,
                prevPage: null,
                items: this
              };
              if (req.query.page + 1 < response.totalPages) {
                response.nextPage = req.path + ("?page=" + (req.query.page + 1) + "&limit=" + req.query.limit);
              }
              if (req.query.page > 0) {
                response.prevPage = req.path + ("?page=" + (req.query.page - 1) + "&limit=" + req.query.limit);
              }
              return callback.call(this, err, response);
            });
          });
        });
      });
    };

    Model.prototype.validate = function(data, callback) {
      return callback();
    };

    Model.prototype.create = function(data, callback) {
      var _this = this;
      return this["import"](data, function() {
        return _this.save(callback);
      });
    };

    Model.prototype.save = function(callback) {
      var _this = this;
      return this.validate(this["export"](), function(err) {
        if (err) {
          return callback(err);
        }
        return _this.table.save(_this.data, function() {
          return callback.apply(_this, arguments);
        });
      });
    };

    Model.prototype.remove = function(conditions, callback) {
      var _this = this;
      if (typeof conditions === 'function') {
        callback = conditions;
        conditions = {};
        conditions._id = this.data._id;
        if (!conditions._id) {
          return callback('Model does not have an ID, so remove was not called.');
        }
      }
      return this.table.remove(conditions, function() {
        return callback.apply(_this, arguments);
      });
    };

    Model.prototype.update = function(query, data, updateOnly, callback) {
      var _this = this;
      if (typeof updateOnly === 'function') {
        callback = updateOnly;
        updateOnly = false;
      }
      return this.load(query, function(err, updated, query) {
        if (updateOnly && !updated) {
          return callback('Not Found');
        }
        return _this["import"](data, function() {
          if (updated) {
            _this.before_update();
          } else {
            _this.before_create();
          }
          return _this.save(function(err) {
            return callback.call(_this, err, updated);
          });
        });
      });
    };

    Model.prototype.before_update = function() {
      return null;
    };

    Model.prototype.before_create = function() {
      return null;
    };

    return Model;

  })();

}).call(this);
