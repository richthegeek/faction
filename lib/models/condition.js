// Generated by CoffeeScript 1.6.3
var Condition_Model, Model, async,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

console.log(__dirname);

async = require('async');

Model = require('./model');

module.exports = Condition_Model = (function(_super) {
  __extends(Condition_Model, _super);

  function Condition_Model(account, callback) {
    this.account = account;
    Condition_Model.__super__.constructor.call(this, account.dbname(), 'conditions', function(self, db, coll) {
      return callback.apply(this, arguments);
    });
  }

  Condition_Model.prototype._spawn = function(callback) {
    return new this.constructor(this.account, callback);
  };

  Condition_Model.route = function(req, res, next) {
    return new Condition_Model(req.account, function() {
      req.model = this;
      return next();
    });
  };

  Condition_Model.prototype.validate = function(data) {
    if (!Array.isArray(data.conditions) || data.conditions.length === 0) {
      throw 'A condition must have an array of conditions to be evaluated.';
    }
  };

  Condition_Model.prototype["export"] = function() {
    var data;
    data = Condition_Model.__super__["export"].apply(this, arguments);
    return {
      condition_id: data.condition_id,
      fact_type: data.fact_type,
      description: data.description,
      conditions: data.conditions
    };
  };

  Condition_Model.prototype.setup = function() {
    this.db.addStreamOperation({
      _id: 'condition_eval',
      sourceCollection: 'fact_updates',
      targetCollection: 'fact_evaluated',
      type: 'untracked',
      operations: [
        {
          operation: 'evaluate_conditions'
        }
      ]
    });
    return this.db.addStreamOperationType('evaluate_conditions', {
      dependencies: {
        'cache': 'shared-cache',
        'async': 'async',
        'fact': __dirname + '/fact',
        'context': 'contextify'
      },
      account: {
        _id: this.account.data._id,
        db: this.account.dbname()
      },
      exec: function(row, callback) {
        var cache, fact_collection,
          _this = this;
        cache = this.modules.cache.create('conditions-' + this.account, true, function(key, next) {
          return _this.stream.db.collection('conditions').find().toArray(next);
        });
        fact_collection = this.stream.db.collection('fact_' + row.type);
        return fact_collection.findOne({
          _id: row.id
        }, function(err, fact) {
          var code, result;
          if (err) {
            return callback(err);
          }
          if (!fact) {
            return callback();
          }
          code = "condition.result = condition.conditions.every(function(condition) {\n	try {\n		return eval(condition);\n	} catch(e) {\n		console.error(e);\n		return false;\n	}\n});";
          result = {};
          return cache.get(function(err, conditions) {
            var condition, sandbox, _i, _len;
            sandbox = {
              fact: _this.modules.fact.prototype.bindFunctions(fact),
              condition: null,
              console: console
            };
            _this.modules.context(sandbox);
            for (_i = 0, _len = conditions.length; _i < _len; _i++) {
              condition = conditions[_i];
              if (!(condition.fact_type === row.type)) {
                continue;
              }
              sandbox.condition = condition;
              sandbox.run(code);
              result[condition.condition_id] = !!sandbox.condition.result;
            }
            return fact_collection.update({
              _id: row.id
            }, {
              $set: {
                _conditions: result
              }
            }, function(err) {
              return callback(err, {
                id: row.id,
                type: row.type,
                result: result,
                time: +(new Date)
              });
            });
          });
        });
      }
    });
  };

  return Condition_Model;

})(Model);
