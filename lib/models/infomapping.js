// Generated by CoffeeScript 1.6.3
var Cache, InfoMapping_Model, Model, crypto,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

crypto = require('crypto');

Model = require('./model');

Cache = require('shared-cache');

module.exports = InfoMapping_Model = (function(_super) {
  __extends(InfoMapping_Model, _super);

  function InfoMapping_Model(account, callback) {
    this.account = account;
    InfoMapping_Model.__super__.constructor.call(this, account.dbname(), 'info_mappings', callback);
  }

  InfoMapping_Model.prototype._spawn = function(callback) {
    return new this.constructor(this.account, callback);
  };

  InfoMapping_Model.route = function(req, res, next) {
    return new InfoMapping_Model(req.account, function() {
      req.model = this;
      return next();
    });
  };

  InfoMapping_Model.prototype.setup = function() {
    this.table.ensureIndex({
      mapping_id: 1,
      info_type: 1
    }, {
      unique: true
    }, function() {
      return null;
    });
    return this.table.ensureIndex({
      fact_type: 1
    }, {}, function() {
      return null;
    });
  };

  InfoMapping_Model.prototype.validate = function(data, callback) {
    if (!data.fact_type) {
      return callback('An information-mapping should have a fact_type property.');
    }
    if (!data.fact_query) {
      return callback('An information-mapping should have a fact_query property defining how a fact is loaded.');
    }
    if (!data.fields || typeof data.fields !== 'object') {
      return callback('An information-mapping should have a fields property defining how data is mapped to facts.');
    }
    if (!data.mapping_id) {
      return callback('An information-mapping must have an ID defined. (This error should not be seen).');
    }
    return callback();
  };

  InfoMapping_Model.prototype.save = function() {
    var _this = this;
    Cache.create('info-mappings-' + this.account.data._id, false, function(key, next) {
      return _this.table.find().toArray(next);
    }).stale();
    return InfoMapping_Model.__super__.save.apply(this, arguments);
  };

  InfoMapping_Model.prototype["export"] = function() {
    return {
      mapping_id: this.data.mapping_id,
      fact_type: this.data.fact_type,
      fact_query: this.data.fact_query,
      fields: this.data.fields
    };
  };

  InfoMapping_Model.prototype.setup = function() {
    this.db.addStreamOperation({
      _id: 'info_handlers',
      type: 'untracked',
      operations: [
        {
          operation: 'info_mapping'
        }
      ],
      sourceCollection: 'info',
      targetCollection: 'fact_updates'
    });
    return this.db.addStreamOperationType('info_mapping', {
      dependencies: {
        cache: 'shared-cache',
        async: 'async',
        xtend: 'xtend',
        'account': __dirname + '/account',
        'fact': __dirname + '/fact'
      },
      "eval": function(str, context) {
        var e;
        try {
          with(context) { result = eval(str) };
          return result;
        } catch (_error) {
          e = _error;
          return str;
        }
      },
      /*
      			interpolate: evaluate demarcated sections of a string
      */

      interpolate: function(str, context) {
        var section, sections, _i, _len, _ref;
        sections = str.match(/\#\{.+?\}/g);
        _ref = sections || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          section = _ref[_i];
          str = str.replace(section, this["eval"](section.slice(2, -1), context));
        }
        return str;
      },
      /*
      			parseObject: evaluate the object with this context, interpolating keys and evaluating leaves.
      				Should transform an object like:
      					"orders": "item", "order_#{item.oid}_value": "item.value"
      				Into this:
      					"orders": {oid: 42, value: 400}, "orders_42_value": 400
      */

      parseObject: function(obj, context) {
        var _this = this;
        return JSON.parse(JSON.stringify(obj), function(key, value) {
          var k, v;
          if (Object.prototype.toString.call(value) === '[object Object]') {
            for (k in value) {
              v = value[k];
              delete value[k];
              k = _this.interpolate(k, context);
              value[k] = v;
            }
          }
          if (typeof value === 'string') {
            value = _this["eval"](value, context);
          }
          return value;
        });
      },
      exec: function(row, callback) {
        var self, time, _mappings, _settings,
          _this = this;
        _mappings = this.modules.cache.create('info-mappings-' + this.account, true, function(key, next) {
          return _this.stream.db.collection('info_mappings').find().toArray(next);
        });
        _settings = this.modules.cache.create('fact-settings-' + this.account, true, function(key, next) {
          return _this.stream.db.collection('fact_settings').find().toArray(next);
        });
        /*
        				A sample mapping:
        					info_type: 'visit',
        					fact_type: 'user',
        					fact_query: '{session_id: info.session_id}',
        					fields:
        						session_id: 'info.session_id'
        						visits:
        							url: 'info.url',
        							time: 'new Date'
        				With this we need to:
        				 - run the fact_query against the facts_user collection
        				 - create the object mapping
        				 - load the fact settings for the "user" fact (cache!)
        				 - execute the fact settings and save.
        
        				A sample fact setting:
        					fact_type: 'user'
        					field_modes:
        						session_id: 'all'
        						visits: 'all'
        					primary_key: ['customer_id']
        
        				With this we need to:
        				 - apply the mapping to the fact
        				 - check that the primary key doesnt result in multiple db entries. If so, merge
        				 - save the damn fact
        */

        self = this;
        time = row._id.getTimestamp();
        return _mappings.get(function(err, mappings) {
          return _settings.get(function(err, settings) {
            var iterator;
            iterator = function(mapping, next) {
              var facts_col, query;
              if (mapping.info_type !== row._type) {
                return next();
              }
              query = self.parseObject(mapping.fact_query, {
                info: row
              });
              facts_col = self.stream.db.collection(self.modules.fact.collectionname(row._type));
              return facts_col.find(query).toArray(function(err, facts) {
                if (err) {
                  return next(err);
                }
                if (facts.length === 0) {
                  facts.push({});
                }
                delete row._type;
                if (Object.prototype.toString.call(row._id) === '[object Object]') {
                  delete row._id;
                }
                return next(null, facts.map(function(fact) {
                  var k, obj, v;
                  obj = self.parseObject(mapping.fields, {
                    info: row,
                    fact: fact
                  });
                  for (k in query) {
                    v = query[k];
                    if (obj[k] == null) {
                      obj[k] = v;
                    }
                  }
                  return {
                    collection: facts_col,
                    fact: fact,
                    mapping: mapping,
                    info: obj
                  };
                }));
              });
            };
            return self.modules.async.map(mappings, iterator, function(err, result) {
              result = [].concat.apply([], result).filter(function(r) {
                return !!r;
              });
              iterator = function(info, next) {
                var field, id, mergeFacts, query, set, setting, _i, _len, _ref;
                setting = ((function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = settings.length; _i < _len; _i++) {
                    set = settings[_i];
                    if (set._id === info.mapping.fact_type) {
                      _results.push(set);
                    }
                  }
                  return _results;
                })()).pop();
                if (setting == null) {
                  setting = {
                    field_modes: {},
                    primary_key: ['_id']
                  };
                }
                mergeFacts = function(old_fact, mid_fact) {
                  var a, ac, b, field, i, j, k, list, mode, new_fact, orig, v, _i, _j, _ref, _ref1, _ref2, _ref3;
                  new_fact = self.modules.xtend(old_fact, mid_fact);
                  _ref = setting.field_modes;
                  for (field in _ref) {
                    mode = _ref[field];
                    if (!mid_fact[field]) {
                      continue;
                    }
                    if (mode === 'all') {
                      orig = old_fact[field] || [];
                      if (!Array.isArray(orig)) {
                        orig = [];
                      }
                      list = orig.concat(mid_fact[field]);
                      for (k in list) {
                        v = list[k];
                        if (!v._time) {
                          list[k] = {
                            _time: new Date,
                            _value: v
                          };
                        }
                      }
                      for (i = _i = 0, _ref1 = list.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                        if (!(a = list[i])) {
                          continue;
                        }
                        ac = JSON.stringify(a._value);
                        for (j = _j = _ref2 = i + 1, _ref3 = list.length; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
                          if (b = list[j]) {
                            if ((a._time - b._time === 0) && ac === JSON.stringify(b._value)) {
                              console.log('EQ', i, j);
                              list[j] = false;
                            }
                          }
                        }
                      }
                      new_fact[field] = list.filter(function(v) {
                        return !!v;
                      });
                    }
                    if (mode === 'oldest') {
                      new_fact[field] = old_fact[field] || mid_fact[field];
                    }
                    if (mode === 'min') {
                      a = Number(mid_fact[field]) || Math.min();
                      b = Number(old_fact[field]) || Math.min();
                      new_fact[field] = Math.min(a, b);
                    }
                    if (mode === 'max') {
                      a = Number(mid_fact[field]) || Math.max();
                      b = Number(old_fact[field]) || Math.max();
                      new_fact[field] = Math.max(a, b);
                    }
                  }
                  return new_fact;
                };
                result = mergeFacts(info.fact, info.info);
                query = {};
                id = [];
                _ref = setting.primary_key;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  field = _ref[_i];
                  id.push(query[field] = result[field]);
                }
                return info.collection.findOne(query, function(err, existing) {
                  var fact;
                  if (err) {
                    return next(err);
                  }
                  if (existing == null) {
                    existing = {};
                  }
                  fact = result;
                  if (existing._id && (existing._id !== info.fact._id)) {
                    fact = mergeFacts(existing, result);
                  }
                  fact._id = id.join('-');
                  return info.collection.update({
                    _id: fact._id
                  }, fact, {
                    upsert: true
                  }, function(err) {
                    console.log(4, arguments);
                    return next(err, {
                      id: fact._id,
                      type: info.mapping.fact_type,
                      time: +(new Date)
                    });
                  });
                });
              };
              return self.modules.async.map(result, iterator, function() {
                return console.log('COMPLETE', arguments);
              });
            });
          });
        });
      }
    });
  };

  return InfoMapping_Model;

})(Model);
