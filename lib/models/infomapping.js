// Generated by CoffeeScript 1.6.3
var Cache, InfoMapping_Model, Model, async, crypto,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

async = require('async');

crypto = require('crypto');

Model = require('./model');

Cache = require('shared-cache');

module.exports = InfoMapping_Model = (function(_super) {
  __extends(InfoMapping_Model, _super);

  function InfoMapping_Model(account, callback) {
    this.account = account;
    InfoMapping_Model.__super__.constructor.call(this, account.dbname(), 'info_mappings', callback);
  }

  InfoMapping_Model.prototype._spawn = function(callback) {
    return new this.constructor(this.account, callback);
  };

  InfoMapping_Model.route = function(req, res, next) {
    return new InfoMapping_Model(req.account, function() {
      req.model = this;
      return next();
    });
  };

  InfoMapping_Model.prototype.setup = function() {
    this.table.ensureIndex({
      mapping_id: 1,
      info_type: 1
    }, {
      unique: true
    }, function() {
      return null;
    });
    return this.table.ensureIndex({
      fact_type: 1
    }, {}, function() {
      return null;
    });
  };

  InfoMapping_Model.prototype.validate = function(data, callback) {
    if (!data.fact_type) {
      return callback('An information-mapping should have a fact_type property.');
    }
    if (!data.fact_identifier) {
      return callback('An information-mapping should have a fact_identifier property defining how a fact is loaded.');
    }
    if (!data.fields || typeof data.fields !== 'object') {
      return callback('An information-mapping should have a fields property defining how data is mapped to facts.');
    }
    if (!data.mapping_id) {
      return callback('An information-mapping must have an ID defined. (This error should not be seen).');
    }
    return callback();
  };

  InfoMapping_Model.prototype.save = function() {
    var _this = this;
    Cache.create('info-mappings-' + this.account.data._id, false, function(key, next) {
      return _this.table.find().toArray(next);
    }).stale();
    return InfoMapping_Model.__super__.save.apply(this, arguments);
  };

  InfoMapping_Model.prototype["export"] = function() {
    return {
      mapping_id: this.data.mapping_id,
      fact_type: this.data.fact_type,
      fact_identifier: this.data.fact_identifier,
      fields: this.data.fields
    };
  };

  InfoMapping_Model.prototype["eval"] = InfoMapping_Model["eval"] = function(str, context, callback) {
    var fn;
    context.isAsync = false;
    context.async = function(val) {
      if (val == null) {
        val = true;
      }
      return context.isAsync = val;
    };
    context.complete = function(err, str) {
      context.complete = function() {
        return null;
      };
      return process.nextTick(function() {
        return typeof callback === "function" ? callback(err, str) : void 0;
      });
    };
    fn = function() {
      var e;
      try {
        with(context) { str = eval(str) };
      } catch (_error) {
        e = _error;
        return context.complete(e, str);
      }
      if (!context.isAsync) {
        context.complete(null, str);
        return str;
      }
      return null;
    };
    return fn.bind({})();
  };

  /*
  	interpolate: evaluate demarcated sections of a string
  */


  InfoMapping_Model.prototype.interpolate = InfoMapping_Model.interpolate = function(str, context, callback) {
    var _this = this;
    (str.match(/\#\{.+?\}/g) || []).forEach(function(section) {
      return str = str.replace(section, InfoMapping_Model["eval"](section.slice(2, -1), context));
    });
    return str;
  };

  /*
  	parseObject: evaluate the object with this context, interpolating keys and evaluating leaves.
  		Should transform an object like:
  			"orders": "item", "order_#{item.oid}_value": "item.value"
  		Into this:
  			"orders": {oid: 42, value: 400}, "orders_42_value": 400
  */


  InfoMapping_Model.prototype.parseObject = InfoMapping_Model.parseObject = function(obj, context, callback) {
    var iter, nodes, traverse,
      _this = this;
    obj = JSON.parse(JSON.stringify(obj), function(key, value) {
      var k, v;
      if (Object.prototype.toString.call(value) === '[object Object]') {
        for (k in value) {
          v = value[k];
          delete value[k];
          k = InfoMapping_Model.interpolate(k, context);
          value[k] = v;
        }
      }
      return value;
    });
    nodes = [];
    traverse = require('traverse');
    traverse(obj).forEach(function(val) {
      if (this.isLeaf) {
        this.value = val;
        return nodes.push(this);
      }
    });
    iter = function(node, next) {
      return InfoMapping_Model["eval"](node.value, context, function(err, newval) {
        return next(err, node.update(newval, true));
      });
    };
    return async.each(nodes, iter, function() {
      return callback(obj);
    });
  };

  InfoMapping_Model.prototype.setup = function() {
    var path;
    path = require('path');
    return this.db.addStreamOperation({
      _id: 'info_handlers',
      type: 'untracked',
      operations: [
        {
          modular: true,
          operation: path.resolve(__dirname, '../../opstreams/info_mapper')
        }
      ],
      sourceCollection: 'info',
      targetCollection: 'fact_updates'
    });
  };

  return InfoMapping_Model;

})(Model);
