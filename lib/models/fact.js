// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, Fact_Model, Model, async,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  async = require('async');

  Model = require('./model');

  Cache = require('shared-cache');

  module.exports = Fact_Model = (function(_super) {
    __extends(Fact_Model, _super);

    function Fact_Model(account, type, callback) {
      this.account = account;
      this.type = type;
      this.type = type.replace(/[^a-z0-9_]+/g, '_').substring(0, 60);
      Fact_Model.__super__.constructor.call(this, account.dbname(), this.collectionname(), function(self, db, coll) {
        return callback.apply(this, arguments);
      });
    }

    Fact_Model.prototype._spawn = function(callback) {
      return new this.constructor(this.account, this.type, callback);
    };

    Fact_Model.collectionname = Fact_Model.prototype.collectionname = function(type) {
      if (type == null) {
        type = this.type;
      }
      return 'facts_' + type.replace(/[^a-z0-9_]+/g, '_').substring(0, 60);
    };

    Fact_Model.route = function(req, res, next) {
      if (req.params['fact-type']) {
        return new Fact_Model(req.account, req.params['fact-type'], function() {
          req.model = this;
          return next();
        });
      } else {
        return next();
      }
    };

    Fact_Model.prototype.setup = function() {
      var path;
      path = require('path');
      return this.db.addStreamOperation({
        _id: 'fact_updater',
        sourceCollection: 'fact_updates',
        targetCollection: 'fact_evaluated',
        type: 'untracked',
        operations: [
          {
            modular: true,
            operation: path.resolve(__dirname, '../../opstreams/fact_updater')
          }, {
            modular: true,
            operation: path.resolve(__dirname, '../../opstreams/condition_evaluator')
          }
        ]
      });
    };

    Fact_Model.prototype.removeFull = function(callback) {
      return this.table.drop(callback);
    };

    Fact_Model.prototype.load = function(query, withFK, callback) {
      var args, self;
      args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      withFK = args.pop() || false;
      self = this;
      return Fact_Model.__super__.load.call(this, query, function(err, row, query) {
        var _this = this;
        if (row && withFK !== false) {
          return this.loadFK(withFK, function(data) {
            return callback.call(_this, err, _this.data, query);
          });
        } else {
          return callback.apply(this, err, this.data, query);
        }
      });
    };

    Fact_Model.prototype.loadAll = function(query, withFK, callback) {
      var args,
        _this = this;
      args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      withFK = args.pop() || false;
      return this.table.find(query, {
        _id: 1
      }).toArray(function(err, ids) {
        var loader;
        loader = function(row, next) {
          return _this._spawn(function() {
            return this.load({
              _id: row._id
            }, withFK, next);
          });
        };
        return async.map(ids, loader, callback);
      });
    };

    Fact_Model.prototype.loadFK = function(chain, callback) {
      var args, self;
      args = Array.prototype.slice.call(arguments);
      callback = args.pop();
      chain = args.pop();
      self = this;
      if (!Array.isArray(chain)) {
        chain = [];
      }
      chain.push(self);
      return this.getSettings(function(err, settings) {
        var fk, fks, key, loadFK;
        if (err || !settings || !settings.foreign_keys) {
          return callback();
        }
        fks = (function() {
          var _ref, _results;
          _ref = settings.foreign_keys;
          _results = [];
          for (key in _ref) {
            fk = _ref[key];
            _results.push([key, fk]);
          }
          return _results;
        })();
        loadFK = function(arr, next) {
          var cb, item, _i, _len,
            _this = this;
          key = arr[0], fk = arr[1];
          for (_i = 0, _len = chain.length; _i < _len; _i++) {
            item = chain[_i];
            if (item.type === fk.fact_type) {
              return next();
            }
          }
          cb = function(err, data) {
            self.data[key] = data;
            return next();
          };
          return Fact_Model.parseObject(fk.query, {
            fact: self.data
          }, function(query) {
            return new Fact_Model(self.account, fk.fact_type, function() {
              if (fk.has === 'one' || (query._id != null)) {
                return this.load(query, chain, cb);
              } else {
                return this.loadAll(query, chain, cb);
              }
            });
          });
        };
        return async.each(fks, loadFK, function() {
          return callback();
        });
      });
    };

    Fact_Model.prototype.addShim = function(callback) {
      var addShim, path;
      path = require('path').resolve(__dirname, '../../opstreams/info_mapper/lib/add_shim');
      addShim = require(path)();
      return addShim(this.data, callback);
    };

    Fact_Model.prototype.updateFields = function(callback) {
      var _this = this;
      return this.addShim(function(err, fact) {
        return _this.getSettings(function(err, settings) {
          var key, props, result, _ref;
          _ref = settings.field_modes;
          for (key in _ref) {
            props = _ref[key];
            if (!props["eval"]) {
              continue;
            }
            result = Fact_Model.evaluate(props["eval"], {
              fact: fact
            });
            fact.set(key, result);
          }
          _this.data = fact;
          return callback.call(_this, err, fact);
        });
      });
    };

    Fact_Model.prototype.getSettings = function(callback) {
      var _this = this;
      if (this.settings_cache == null) {
        this.settings_cache = Cache.create('fact-settings-' + this.account.data._id, true, function(key, next) {
          return _this.db.collection('fact_settings').find().toArray(next);
        });
      }
      return this.settings_cache.get(function(err, settings) {
        return callback(err, settings.filter(function(setting) {
          return setting._id === _this.type;
        }).pop());
      });
    };

    Fact_Model.getTypes = function(account, callback) {
      return mongodb.open(account.dbname(), function(err, db) {
        return db.collectionNames(function(err, cl) {
          var collections, filter, rename, result, trim;
          collections = cl;
          rename = function(row) {
            return row.name.split('.').pop();
          };
          filter = function(name) {
            return name.slice(0, 6) === 'facts_';
          };
          trim = function(name) {
            return name.slice(6);
          };
          result = cl.map(rename).filter(filter).map(trim);
          result.detailed = function(callback) {
            var iter;
            iter = function(type, next) {
              return new Fact_Model(account, type, function() {
                return this.table.count(function(err, size) {
                  return next(err, {
                    fact_type: type,
                    fact_sources: 'todo',
                    count: size,
                    nextPage: "/facts/" + type
                  });
                });
              });
            };
            return async.map(result, iter, function(err, info) {
              var fact, obj, _i, _len, _ref;
              obj = {};
              _ref = info || [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                fact = _ref[_i];
                obj[fact.fact_type] = fact;
              }
              return callback(err, obj);
            });
          };
          return callback(err, result);
        });
      });
    };

    return Fact_Model;

  })(Model);

  Fact_Model.evaluate = function(str, context, callback) {
    var fn;
    context.isAsync = false;
    context.async = function(val) {
      if (val == null) {
        val = true;
      }
      return context.isAsync = val;
    };
    context.complete = function(err, str) {
      context.complete = function() {
        return null;
      };
      return process.nextTick(function() {
        return typeof callback === "function" ? callback(err, str) : void 0;
      });
    };
    fn = function() {
      var e;
      try {
        with(context) { str = eval(str) };
      } catch (_error) {
        e = _error;
        return context.complete(e, str);
      }
      if (!context.isAsync) {
        context.complete(null, str);
        return str;
      }
      return null;
    };
    return fn.bind({})();
  };

  /*
  interpolate: evaluate demarcated sections of a string
  */


  Fact_Model.interpolate = function(str, context, callback) {
    var _this = this;
    (str.match(/\#\{.+?\}/g) || []).forEach(function(section) {
      return str = str.replace(section, Fact_Model.evaluate(section.slice(2, -1), context));
    });
    return str;
  };

  /*
  parseObject: evaluate the object with this context, interpolating keys and evaluating leaves.
  	Should transform an object like:
  		"orders": "item", "order_#{item.oid}_value": "item.value"
  	Into this:
  		"orders": {oid: 42, value: 400}, "orders_42_value": 400
  */


  Fact_Model.parseObject = function(obj, context, callback) {
    var iter, nodes, traverse,
      _this = this;
    obj = JSON.parse(JSON.stringify(obj), function(key, value) {
      var k, v;
      if (Object.prototype.toString.call(value) === '[object Object]') {
        for (k in value) {
          v = value[k];
          delete value[k];
          k = Fact_Model.interpolate(k, context);
          value[k] = v;
        }
      }
      return value;
    });
    nodes = [];
    traverse = require('traverse');
    traverse(obj).forEach(function(val) {
      if (this.isLeaf) {
        this.value = val;
        return nodes.push(this);
      }
    });
    iter = function(node, next) {
      return Fact_deferred_Model.evaluate(node.value, context, function(err, newval) {
        if (err) {
          return next(err, null);
        } else {
          return next(null, node.update(newval, true));
        }
      });
    };
    return async.each(nodes, iter, callback);
  };

}).call(this);

/*
//@ sourceMappingURL=fact.map
*/
