// Generated by CoffeeScript 1.6.3
var Info_Model, Model, check, crypto,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

check = require('validator').check;

crypto = require('crypto');

Model = require('./model');

module.exports = Info_Model = (function(_super) {
  __extends(Info_Model, _super);

  function Info_Model(account, callback) {
    this.account = account;
    Info_Model.__super__.constructor.call(this, account.dbname(), 'info', callback);
  }

  Info_Model.prototype._spawn = function(callback) {
    return new this.constructor(this.account, callback);
  };

  Info_Model.prototype.create = function(type, info, callback) {
    if (typeof info === 'function') {
      callback = info;
      info = {};
    }
    delete info._id;
    info._type = type;
    return this.table.insert(info, callback);
  };

  Info_Model.route = function(req, res, next) {
    return new Info_Model(req.account, function() {
      req.model = this;
      return next();
    });
  };

  Info_Model.prototype.setup = function() {
    this.table.addStreamOperation({
      _id: 'info_handlers',
      type: 'untracked',
      operations: [
        {
          operation: 'info_multiplex'
        }
      ],
      targetCollection: 'fact_updates'
    });
    return this.table.addStreamOperationType('info_multiplex', {
      dependencies: ['shared-cache', 'async'],
      account: this.account.data._id,
      exec: function(row, callback) {
        var handler_cache, interpolate, modes, time,
          _this = this;
        handler_cache = this.modules['shared-cache'].create('info-handlers-' + this.account, true, function(key, next) {
          return _this.stream.db.collection('info_handlers').find().toArray(next);
        });
        interpolate = function(str, context) {
          var k, section, sections, v, _i, _len;
          for (k in context) {
            v = context[k];
            this[k] = v;
          }
          sections = str.match(/\#\{.+?\}/g);
          for (_i = 0, _len = sections.length; _i < _len; _i++) {
            section = sections[_i];
            with(context) { result = eval(section.slice(2,-1)) };
            str = str.replace(section, result);
          }
          return str;
        };
        time = row._id.getTimestamp();
        modes = {
          all: function(fact, set, col, val) {
            if (set.$push == null) {
              set.$push = {};
            }
            return set.$push[col] = {
              _value: val,
              _date: time
            };
          },
          oldest: function(fact, set, col, val) {
            if (fact[col] == null) {
              if (set.$set == null) {
                set.$set = {};
              }
              return set.$set[col] = val;
            }
          },
          newest: function(fact, set, col, val) {
            if (set.$set == null) {
              set.$set = {};
            }
            return set.$set[col] = val;
          },
          min: function(fact, set, col, val) {
            var min, _ref;
            min = (_ref = fact[col]) != null ? _ref : Math.min();
            if (Number(val) < min) {
              if (set.$set == null) {
                set.$set = {};
              }
              return set.$set[col] = val;
            }
          },
          max: function(fact, set, col, val) {
            var max, _ref;
            max = (_ref = fact[col]) != null ? _ref : Math.max();
            if (Number(val) > max) {
              if (set.$set == null) {
                set.$set = {};
              }
              return set.$set[col] = val;
            }
          }
        };
        return handler_cache.get(function(err, handlers, cache_hit) {
          var iterator;
          iterator = function(handler, next) {
            var collection, e, id, type, update;
            if (handler.info_type !== row._type) {
              return next();
            }
            try {
              id = interpolate(handler.fact_identifier, row);
              type = handler.fact_type.replace(/[^a-z0-9_]+/g, '_').substring(0, 60);
              collection = _this.stream.db.collection('fact_' + type);
              return collection.findOne({
                _id: id
              }, function(err, fact) {
                var col, columns, fn, mode, set, str, val, _ref;
                set = {};
                fact = fact || {};
                _ref = handler.track;
                for (mode in _ref) {
                  columns = _ref[mode];
                  for (col in columns) {
                    str = columns[col];
                    val = interpolate(str, row);
                    if (fn = modes[mode]) {
                      fn(fact, set, col, val);
                    }
                  }
                }
                return collection.update({
                  _id: id
                }, set, {
                  upsert: true
                }, function(err) {
                  return next(err, {
                    id: id,
                    type: type,
                    time: +(new Date),
                    query: JSON.stringify(set)
                  });
                });
              });
            } catch (_error) {
              e = _error;
              update = {
                $push: {
                  errors: {
                    $each: [
                      {
                        message: e.toString(),
                        time: new Date
                      }
                    ],
                    $slice: -10
                  }
                }
              };
              _this.stream.db.collection('info_handlers').update({
                _id: handler._id
              }, update);
              console.error('Info_Handler failure', e);
              return next();
            }
          };
          return _this.modules.async.eachSeries(handlers, iterator, function(err) {
            return callback(err, null);
          });
        });
      }
    });
  };

  return Info_Model;

})(Model);
