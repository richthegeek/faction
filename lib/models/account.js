// Generated by CoffeeScript 1.6.3
var Account, Model, check, crypto,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

check = require('validator').check;

crypto = require('crypto');

Model = require('./model');

module.exports = Account = (function(_super) {
  __extends(Account, _super);

  function Account(callback) {
    Account.__super__.constructor.call(this, 'core', 'accounts', callback);
  }

  Account.prototype._spawn = function(callback) {
    return new this.constructor(callback);
  };

  Account.prototype.dbname = function() {
    return 'account_' + this.data._id;
  };

  Account.prototype.create = function(info, callback) {
    var base,
      _this = this;
    if (typeof info === 'function') {
      callback = info;
      info = {};
    }
    this.data = {};
    base = new Date().getTime().toString() + Math.round(1000 * Math.random());
    this.data._id = crypto.createHash('sha1').update(base).digest('hex').substring(0, 16);
    return this.setContact(info, function(err) {
      if (err) {
        return callback(err);
      }
      return _this.generateKey('primary', null, callback);
    });
  };

  Account.prototype.setContact = function(info, callback) {
    var k, v, _base;
    info = info.contact || info;
    if ((_base = this.data).contact == null) {
      _base.contact = {};
    }
    for (k in info) {
      v = info[k];
      if (v) {
        this.data.contact[k] = v;
      }
    }
    check(this.data.contact.name, {
      notNull: 'Contact name (body property: "name") must be non-empty',
      notEmpty: 'Contact name (body property: "name") must be non-empty'
    }).notNull().notEmpty();
    check(this.data.contact.email, {
      notNull: 'Contact email (body property: "email") must be non-empty',
      isEmail: 'Contact email (body property: "email") must be valid'
    }).notNull().isEmail();
    console.log('.');
    return this.save(callback);
  };

  Account.prototype.generateKey = function(name, parent, callback) {
    var _base,
      _this = this;
    if ((_base = this.data).keys == null) {
      _base.keys = {};
    }
    if (parent && (this.data.keys[parent] == null)) {
      return callback('The specified parent does not exist.');
    }
    this.data.keys[name] = {
      name: name,
      parent: parent,
      "public": this.data._id + crypto.createHash('sha1').update(Math.random() + +new Date() + 'public').digest('hex').substring(0, 16),
      "private": crypto.createHash('sha512').update(Math.random() + +new Date() + 'private').digest('hex')
    };
    return this.save(function(err) {
      return callback(err, _this.data.keys[name]);
    });
  };

  Account.prototype.deleteKey = function(name, callback) {
    var k, key, keys, _i, _len;
    keys = this.getChildKeys(name);
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      delete this.data.keys[key.name];
    }
    if (((function() {
      var _results;
      _results = [];
      for (k in this.data.keys) {
        if (k) {
          _results.push(1);
        }
      }
      return _results;
    }).call(this)).length === 0) {
      throw 'Deleting this key would result in this account having no keys. Aborting!';
    }
    return this.save(function(err) {
      return callback(err, keys);
    });
  };

  Account.prototype.getChildKeys = function(parent, andSelf, limit) {
    var children, key, name, _ref;
    if (andSelf == null) {
      andSelf = true;
    }
    if (limit == null) {
      limit = 100;
    }
    if (limit === 0) {
      return [];
    }
    children = [];
    if (andSelf) {
      children.push(this.data.keys[parent]);
    }
    _ref = this.data.keys;
    for (name in _ref) {
      key = _ref[name];
      if (key.parent === parent) {
        children = children.concat(this.getChildKeys(key.name, true, limit - 1));
      }
    }
    return children;
  };

  Account.prototype["export"] = function(key) {
    var data, keys, _i, _len;
    data = Account.__super__["export"].apply(this, arguments);
    if (key) {
      keys = this.getChildKeys(key.name);
      data.keys = {};
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        data.keys[key.name] = key;
      }
    }
    return data;
  };

  return Account;

})(Model);
