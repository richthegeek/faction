// Generated by CoffeeScript 1.6.3
var Action_Model, Cache, Model, async,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

async = require('async');

Model = require('./model');

Cache = require('shared-cache');

module.exports = Action_Model = (function(_super) {
  __extends(Action_Model, _super);

  function Action_Model(account, callback) {
    this.account = account;
    Action_Model.__super__.constructor.call(this, account.dbname(), 'actions', function(self, db, coll) {
      return callback.apply(this, arguments);
    });
  }

  Action_Model.prototype._spawn = function(callback) {
    return new this.constructor(this.account, callback);
  };

  Action_Model.route = function(req, res, next) {
    return new Action_Model(req.account, function() {
      req.model = this;
      return next();
    });
  };

  Action_Model.prototype.validate = function(data, callback) {
    var action, _i, _len, _ref;
    if (!data.conditions) {
      throw 'An action must have a map of conditions determining wether it is run.';
    }
    if (data.perform_once_per_fact == null) {
      data.perform_once_per_fact = false;
    }
    if (!Array.isArray(data.actions) || data.actions.length === 0) {
      throw 'An action must have an array of at least 1 action to perform.';
    }
    _ref = data.actions;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      action = _ref[_i];
      if (!action || !action.action) {
        throw 'All actions must be an object with an "action" property.';
      }
    }
    return this.actionTypes(function(err, types) {
      var iterator;
      iterator = function(action, next) {
        var type;
        if (!(type = types[action.action])) {
          throw "Unknown action '" + action.action + "'. GET /action-types to see a valid list.";
        }
        return type.validate(action, function(err) {
          if (err) {
            return next("Action '" + action.action + "' could not validate: " + err);
          }
          return next();
        });
      };
      return async.each(data.actions, iterator, callback);
    });
  };

  Action_Model.prototype["export"] = function() {
    var data;
    data = Action_Model.__super__["export"].apply(this, arguments);
    return {
      action_id: data.action_id,
      fact_type: data.fact_type,
      actions: data.actions,
      conditions: data.conditions,
      perform_once_per_fact: !!data.perform_once_per_fact
    };
  };

  Action_Model.prototype.fact_is_runnable = function(factObj) {
    var condition, data, fact, val, _ref;
    data = this["export"]();
    fact = factObj["export"]();
    _ref = data.conditions;
    for (condition in _ref) {
      val = _ref[condition];
      if (fact._conditions[condition] !== val) {
        return false;
      }
    }
    return true;
  };

  Action_Model.prototype.fact_run = function(factObj, stage, callback) {
    var _this = this;
    if (typeof stage === 'function') {
      callback = stage;
      stage = 0;
    }
    if (typeof Number(stage) !== 'number') {
      stage = 0;
    }
    if (stage === 0) {
      if (!this.fact_is_runnable(factObj)) {
        return callback(null, false);
      }
    }
    return this.actionTypes(function(err, types) {
      var runner;
      runner = function(action, next) {
        var type;
        if (type = types[action.action]) {
          return type.exec(action, factObj["export"](), next);
        }
      };
      return async.mapSeries(_this.data.actions.slice(stage), runner, callback);
    });
  };

  Action_Model.prototype.actionTypes = function(callback) {
    var cache,
      _this = this;
    cache = Cache.create('action-types', true, function(key, next) {
      var dir, file, fs, name, object, path, types, _i, _len, _ref;
      fs = require('fs');
      path = require('path');
      dir = path.resolve(__dirname, '../actions');
      types = {};
      _ref = fs.readdirSync(dir);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        if (!(file.substr(-3) === '.js')) {
          continue;
        }
        name = file.slice(0, -3);
        object = require(dir + '/' + file);
        types[object.name] = object;
      }
      return next(null, types);
    });
    return cache.get(callback);
  };

  Action_Model.prototype.setup = function() {
    this.db.addStreamOperation({
      _id: 'action_eval',
      sourceCollection: 'fact_evaluated',
      targetCollection: 'action_results',
      type: 'untracked',
      operations: [
        {
          operation: 'perform_action'
        }
      ]
    });
    return this.db.addStreamOperationType('perform_action', {
      dependencies: {
        'cache': 'shared-cache',
        'async': 'async',
        'fact': __dirname + '/fact',
        'action': __dirname + '/action'
      },
      account: {
        _id: this.account.data._id,
        databaseName: this.account.dbname()
      },
      exec: function(row, callback) {
        var account, cache, modules,
          _this = this;
        cache = this.modules.cache.create('actions-' + this.account, true, function(key, next) {
          return _this.stream.db.collection('actions').find().toArray(next);
        });
        modules = this.modules;
        account = this.account;
        account.dbname = function() {
          return account.databaseName;
        };
        return new modules.fact(account, row.type, function(self) {
          return this.load({
            _id: row.id
          }, function(err) {
            var fact, iterator;
            fact = this;
            iterator = function(action, next) {
              if (action.fact_type !== fact.type) {
                return next();
              }
              return new modules.action(account, function(err) {
                return this["import"](action, function() {
                  action = this;
                  return this.fact_run(fact, row.stage || 0, function(err, result) {
                    return next(err, result && {
                      action_id: action.data.action_id,
                      fact_type: action.data.fact_type,
                      fact_id: row.id,
                      time: new Date,
                      result: err || result,
                      status: err && 'error' || 'ok'
                    });
                  });
                });
              });
            };
            return cache.get(function(err, actions) {
              return modules.async.map(actions, iterator, function(err, rows) {
                return callback(null, rows);
              });
            });
          });
        });
      }
    });
  };

  return Action_Model;

})(Model);
