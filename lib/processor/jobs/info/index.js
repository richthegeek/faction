// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, addShim, async, evaluate, markForeignFacts, mergeFacts, parseObject, _ref;

  async = require('async');

  Cache = require('shared-cache');

  mergeFacts = require('./merge_facts');

  markForeignFacts = require('./mark_foreign_facts');

  addShim = require('./add_shim');

  _ref = require('./eval'), evaluate = _ref.evaluate, parseObject = _ref.parseObject;

  module.exports = function(job, done) {
    var account, accountID, fns, row, time;
    job.progress(0, 3);
    job.state('inactive');
    account = null;
    accountID = job.data.account;
    time = new Date(parseInt(job.created_at));
    row = job.data.data;
    fns = {};
    fns.account = function(next) {
      return loadAccount(accountID, function(err, acc) {
        if (err || !acc) {
          return console.log('Failed to get account', err(acc));
        }
        account = acc;
        return next(err);
      });
    };
    fns.setup = function(next) {
      if (account.mappings == null) {
        account.mappings = Cache.create('info-mappings-' + accountID, true, function(key, next) {
          return account.database.collection('info_mappings').find().toArray(next);
        });
      }
      if (account.settings == null) {
        account.settings = Cache.create('fact-settings-' + accountID, true, function(key, next) {
          return account.database.collection('fact_settings').find().toArray(function(err, settings) {
            var collections, ensureIndex, fk, fks, setting, _i, _len, _ref1;
            if (err || !settings) {
              return next(err, settings);
            }
            collections = {};
            ensureIndex = function(fk, next) {
              var index, val, _name, _ref1;
              if (collections[_name = fk.fact_type] == null) {
                collections[_name] = account.database.collection(Fact_Model.collectionname(fk.fact_type));
              }
              index = {};
              _ref1 = fk.query;
              for (key in _ref1) {
                val = _ref1[key];
                index[key] = 1;
              }
              if (index._id) {
                return next();
              }
              return collections[fk.fact_type].ensureIndex(index, next);
            };
            fks = [];
            for (_i = 0, _len = settings.length; _i < _len; _i++) {
              setting = settings[_i];
              _ref1 = setting.foreign_keys;
              for (key in _ref1) {
                fk = _ref1[key];
                fks.push(fk);
              }
            }
            return async.map(fks, ensureIndex, function() {
              return next(err, settings);
            });
          });
        });
      }
      return next();
    };
    fns.mappings = function(next) {
      return account.mappings.get(function(e, r) {
        return next(e, r);
      });
    };
    fns.settings = function(next) {
      return account.settings.get(function(e, r) {
        return next(e, r);
      });
    };
    return async.series(fns, function(err, results) {
      var combineMappings, mappings, parseMappings, settings;
      job.progress(1, 3);
      mappings = results.mappings.filter(function(mapping) {
        return mapping && mapping.info_type === row._type;
      });
      settings = results.settings;
      /*
      		A sample mapping:
      			info_type: 'visit',
      			fact_type: 'sessions',
      			fact_identifier: 'info.sid',
      			fields:
      				uid: 'info.uid'
      				visits:
      					url: 'info.url',
      					time: 'new Date'
      
      		A sample fact setting:
      			fact_type: 'sessions'
      			field_modes:
      				actions: 'all'
      				score:
      					eval: "
      						async();
      						http.request("http://trakapo.com/score", {})
      
      					"
      			foreign_keys:
      				user:
      					fact_type: 'users'
      					has: 'one'
      					query:
      						_id: 'fact.uid'
      
      		With this we need to:
      		 - find the fact_identifier in the facts_sessions collection
      		 - load the fact settings for the "sessions" fact (cache!)
      		 - merge the new info into the existing fact
      		 - save, ping any FKs as updated.
      */

      parseMappings = function(mapping, next) {
        var query, _ref1;
        query = {
          _id: evaluate(mapping.fact_identifier, {
            info: row
          })
        };
        if (query._id == null) {
          return next();
        }
        mapping.update_only = !!((_ref1 = mapping.update_only) != null ? _ref1 : false);
        if (mapping.conditions == null) {
          mapping.conditions = [];
        }
        return new Fact_deferred_Model(account, mapping.fact_type, function() {
          var model,
            _this = this;
          model = this;
          return this.load(query, false, function(err, fact) {
            if (fact == null) {
              fact = {};
            }
            if (err) {
              return next(err);
            }
            if ((mapping.update_only === true) && !fact) {
              return next();
            }
            return _this.addShim(function(err, fact) {
              var context;
              delete row._type;
              if (Object.prototype.toString.call(row._id) === '[object Object]') {
                delete row._id;
              }
              context = {
                info: row,
                fact: fact
              };
              return parseObject(mapping.fields, context, function(obj) {
                obj._id = query._id;
                return next(null, {
                  model: model,
                  fact: fact || {},
                  mapping: mapping,
                  info: obj
                });
              });
            });
          });
        });
      };
      combineMappings = function(info, next) {
        var fact, key, mode, s, set, _ref1;
        set = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = settings.length; _i < _len; _i++) {
            s = settings[_i];
            if (s._id === info.model.type) {
              _results.push(s);
            }
          }
          return _results;
        })()).pop() || {
          foreign_keys: {}
        };
        for (key in set.foreign_keys) {
          info.fact.del(key);
        }
        set.time = time;
        fact = mergeFacts(set, info.fact, info.info);
        _ref1 = set.field_modes;
        for (key in _ref1) {
          mode = _ref1[key];
          if (mode === 'delete') {
            info.fact.del.call(fact, key);
          }
        }
        fact._updated = new Date;
        if (!fact._id) {
          return next();
        }
        return info.model.table.save(fact, function(err) {
          return next(err, {
            fact_id: fact._id,
            fact_type: info.mapping.fact_type,
            version: fact._updated
          });
        });
      };
      return async.map(mappings, parseMappings, function(err, result) {
        job.progress(2, 3);
        result = [].concat.apply([], result).filter(Boolean);
        return async.map(result, combineMappings, function(err, result) {
          var _i, _len;
          job.progress(3, 3);
          result = [].concat.apply([], result);
          result = [].concat.apply([], result);
          result = result.filter(Boolean).filter(function(r) {
            return !Array.isArray(r);
          });
          for (_i = 0, _len = result.length; _i < _len; _i++) {
            row = result[_i];
            if (!(result)) {
              continue;
            }
            job = jobs.create('fact_update', {
              title: "" + row.fact_type + " - " + row.fact_id,
              account: accountID,
              data: row
            });
            job.save();
          }
          return done(err, result);
        });
      });
    });
  };

  module.exports.concurrency = 3;

  module.exports.timeout = 1000;

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
