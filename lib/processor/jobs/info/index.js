// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, addShim, async, deleteColumn, evaluate, getColumn, markForeignFacts, mergeFacts, moment, parseObject, setColumn, _ref, _ref1;

  async = require('async');

  Cache = require('shared-cache');

  moment = require('moment');

  mergeFacts = require('./merge_facts');

  markForeignFacts = require('./mark_foreign_facts');

  addShim = require('./add_shim');

  _ref = require('./eval'), evaluate = _ref.evaluate, parseObject = _ref.parseObject;

  _ref1 = require('./column_ops'), getColumn = _ref1.getColumn, setColumn = _ref1.setColumn, deleteColumn = _ref1.deleteColumn;

  module.exports = {
    concurrency: 1,
    timeout: 1000,
    exec: function(job, done) {
      var account, accountID, fns, row, time;
      job.progress(0, 3);
      account = null;
      accountID = job.data.account;
      time = new Date(parseInt(job.created_at));
      row = job.data.data;
      fns = {};
      fns.account = function(next) {
        return loadAccount(accountID, function(err, acc) {
          if (err || !acc) {
            return console.log('Failed to get account', err(acc));
          }
          account = acc;
          return next(err);
        });
      };
      fns.setup = function(next) {
        if (account.mappings == null) {
          account.mappings = Cache.create('info-mappings-' + accountID, true, function(key, next) {
            return account.database.collection('info_mappings').find().toArray(next);
          });
        }
        if (account.settings == null) {
          account.settings = Cache.create('fact-settings-' + accountID, true, function(key, next) {
            return account.database.collection('fact_settings').find().toArray(function(err, settings) {
              var collections, ensureIndex, fk, fks, setting, _i, _len, _ref2;
              if (err || !settings) {
                return next(err, settings);
              }
              collections = {};
              ensureIndex = function(fk, next) {
                var index, val, _name, _ref2;
                if (collections[_name = fk.fact_type] == null) {
                  collections[_name] = account.database.collection(Fact_Model.collectionname(fk.fact_type));
                }
                index = {};
                _ref2 = fk.query;
                for (key in _ref2) {
                  val = _ref2[key];
                  index[key] = 1;
                }
                if (index._id) {
                  return next();
                }
                return collections[fk.fact_type].ensureIndex(index, next);
              };
              fks = [];
              for (_i = 0, _len = settings.length; _i < _len; _i++) {
                setting = settings[_i];
                _ref2 = setting.foreign_keys;
                for (key in _ref2) {
                  fk = _ref2[key];
                  fks.push(fk);
                }
              }
              return async.map(fks, ensureIndex, function() {
                return next(err, settings);
              });
            });
          });
        }
        return next();
      };
      fns.mappings = function(next) {
        return account.mappings.get(function(e, r) {
          return next(e, r);
        });
      };
      fns.settings = function(next) {
        return account.settings.get(function(e, r) {
          return next(e, r);
        });
      };
      return async.series(fns, function(err, results) {
        var combineMappings, mappings, parseMappings, settings;
        job.progress(1, 3);
        mappings = results.mappings.filter(function(mapping) {
          return mapping && (!mapping.disabled) && mapping.info_type === row._type;
        });
        settings = results.settings;
        /*
        			A sample mapping:
        				info_type: 'visit',
        				fact_type: 'sessions',
        				fact_identifier: 'info.sid',
        				fields:
        					uid: 'info.uid'
        					visits:
        						url: 'info.url',
        						time: 'new Date'
        
        			A sample fact setting:
        				fact_type: 'sessions'
        				field_modes:
        					actions: 'all'
        					score:
        						eval: "
        							async();
        							http.request("http://trakapo.com/score", {})
        
        						"
        				foreign_keys:
        					user:
        						fact_type: 'users'
        						has: 'one'
        						query:
        							_id: 'fact.uid'
        
        			With this we need to:
        			 - find the fact_identifier in the facts_sessions collection
        			 - load the fact settings for the "sessions" fact (cache!)
        			 - merge the new info into the existing fact
        			 - save, ping any FKs as updated.
        */

        parseMappings = function(mapping, next) {
          var context, query, _ref2;
          context = {
            info: row,
            moment: moment,
            url: function(value, key) {
              if (key == null) {
                key = 'href';
              }
              return require('url').parse(value, true)[key];
            }
          };
          query = {
            _id: evaluate(mapping.fact_identifier, context)
          };
          if (mapping.debug) {
            console.log('Query', query);
          }
          if (query._id == null) {
            return next();
          }
          mapping.update_only = !!((_ref2 = mapping.update_only) != null ? _ref2 : false);
          if (mapping.conditions == null) {
            mapping.conditions = [];
          }
          return new Fact_deferred_Model(account, mapping.fact_type, function() {
            var model,
              _this = this;
            model = this;
            return this.load(query, true, function(err, fact) {
              if (fact == null) {
                fact = {};
              }
              if (err) {
                return next(err);
              }
              if ((mapping.update_only === true) && !fact) {
                console.log('Skip due to update_only', mapping.fact_type, query);
                return next();
              }
              return _this.addShim(function(err, fact) {
                var evalCond;
                delete row._type;
                if (Object.prototype.toString.call(row._id) === '[object Object]') {
                  delete row._id;
                }
                context.fact = fact;
                evalCond = function(cond, next) {
                  return Fact_deferred_Model.evaluate(cond, context, next);
                };
                return async.map(mapping.conditions, evalCond, function(err, conds) {
                  var pass;
                  conds.push(!err);
                  pass = conds.every(Boolean);
                  if (!pass) {
                    if (mapping.debug) {
                      console.log('Skip due to condition failure', "\n\t" + mapping.conditions.map(function(v, i) {
                        return [v, !!conds[i]].join(' ');
                      }).join("\n\t"));
                    }
                    return next();
                  }
                  return parseObject(mapping.fields, context, function(obj) {
                    var key, val;
                    obj._id = query._id;
                    if (mapping.debug) {
                      console.log('Mapped', mapping, obj);
                    }
                    for (key in obj) {
                      val = obj[key];
                      if (!(key.indexOf('.') >= 0)) {
                        continue;
                      }
                      delete obj[key];
                      setColumn(obj, key, val);
                    }
                    return next(null, {
                      model: model,
                      fact: fact || {},
                      mapping: mapping,
                      info: obj
                    });
                  });
                });
              });
            });
          });
        };
        combineMappings = function(info, next) {
          var fact, key, merge, options, opts, query, s, set, updateObj, updates, _name;
          set = ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = settings.length; _i < _len; _i++) {
              s = settings[_i];
              if (s._id === info.model.type) {
                _results.push(s);
              }
            }
            return _results;
          })()).pop() || {
            foreign_keys: {}
          };
          for (key in set.foreign_keys) {
            info.fact.del(key);
          }
          set.time = time;
          merge = mergeFacts(set, info.fact.data, info.info);
          fact = merge.fact;
          updates = merge.updates;
          updates._updated = {
            type: '$set',
            value: time
          };
          fact._updated = time;
          if (!fact._id) {
            if (info.mapping.debug) {
              console.log('No Fact ID', fact);
            }
            return next();
          }
          delete updates._id;
          updateObj = {};
          for (key in updates) {
            opts = updates[key];
            if (!(opts)) {
              continue;
            }
            if (updateObj[_name = opts.type] == null) {
              updateObj[_name] = {};
            }
            updateObj[opts.type][key] = opts.value;
          }
          query = {
            _id: fact._id
          };
          options = {
            upsert: true
          };
          if (info.mapping.debug) {
            console.log('Write', query, updateObj);
          }
          return info.model.table.update(query, updateObj, options, function(err) {
            return next(err, {
              fact_id: fact._id,
              fact_type: info.mapping.fact_type,
              version: fact._updated
            });
          });
        };
        return async.map(mappings, parseMappings, function(err, result) {
          if (err) {
            return done(err);
          }
          job.progress(2, 3);
          result = [].concat.apply([], result).filter(Boolean);
          return async.map(result, combineMappings, function(err, result) {
            var _i, _len;
            job.progress(3, 3);
            result = [].concat.apply([], result);
            result = [].concat.apply([], result);
            result = result.filter(Boolean).filter(function(r) {
              return !Array.isArray(r);
            });
            for (_i = 0, _len = result.length; _i < _len; _i++) {
              row = result[_i];
              if (!(result)) {
                continue;
              }
              job = jobs.create('fact_update', {
                title: "" + row.fact_type + " - " + row.fact_id,
                account: accountID,
                data: row
              });
              job.save();
            }
            return done(err, result);
          });
        });
      });
    }
  };

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
