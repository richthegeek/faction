// Generated by CoffeeScript 1.6.3
(function() {
  var deleteColumn, getColumn, moment, setColumn, traverse, url, _ref,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  _ref = require('./column_ops'), getColumn = _ref.getColumn, setColumn = _ref.setColumn, deleteColumn = _ref.deleteColumn;

  moment = require('moment');

  traverse = require('traverse');

  url = require('url');

  module.exports = function(data) {
    var bind_array, bind_iterable, fn;
    bind_array = function(value) {
      var compare, item;
      if (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          item = value[_i];
          if ((item._value != null) && (item._date != null)) {
            _results.push(1);
          }
        }
        return _results;
      })()).length > 0) {
        value.over = function(period, time) {
          var bits, duration, end, seconds, start;
          end = Number(time) || new Date().getTime();
          if (bits = period.match(/^([0-9]+) (second|minute|hour|day|week|month|year)/)) {
            duration = moment.duration(Number(bits[1]), bits[2]);
            start = end - duration;
            if (0 === duration.as('milliseconds')) {
              throw 'Invocation of Array.over with invalid duration string.';
            }
          } else if (seconds = Number(period)) {
            start = end - seconds;
          } else {
            throw 'Invocation of Array.over with invalid duration value.';
          }
          return this.betweenDates(start, end);
        };
        value.before = function(time) {
          return this.betweenDates(0, time);
        };
        value.after = function(time) {
          return this.betweenDates(time, new Date);
        };
        value.betweenDates = function(start, end) {
          return bind_array(this.filter(function(item) {
            var _ref1;
            return (new Date(start) <= (_ref1 = new Date(item._date || new Date())) && _ref1 <= new Date(end));
          }));
        };
      }
      value.values = function(column) {
        return bind_array(this.filter(function(v) {
          return typeof v !== 'function';
        }).map(function(v) {
          var _ref1;
          v = (_ref1 = v._value) != null ? _ref1 : v;
          return column && v[column] || v;
        }));
      };
      value.sum = function(column) {
        return this.values(column).reduce((function(pv, cv) {
          return pv + (cv | 0);
        }), 0);
      };
      value.max = function(column) {
        return this.values(column).reduce((function(pv, item) {
          return Math.max(pv, item | 0);
        }), Math.max());
      };
      value.min = function(column) {
        return this.values(column).reduce((function(pv, item) {
          return Math.min(pv, item | 0);
        }), Math.min());
      };
      value.mean = function(column) {
        return this.sum(column) / this.values(column).length;
      };
      compare = function(column, val, fn) {
        var args;
        args = Array.prototype.slice.call(arguments);
        fn = args.pop();
        val = args.pop();
        column = args.pop();
        return this.values(column).filter(function(v) {
          return fn(val, v);
        });
      };
      value.gt = function(column, val) {
        return compare.call(this, column, val, function(val, v) {
          return v > val;
        });
      };
      value.gte = function(column, val) {
        return compare.call(this, column, val, function(val, v) {
          return v >= val;
        });
      };
      value.lt = function(column, val) {
        return compare.call(this, column, val, function(val, v) {
          return v < val;
        });
      };
      value.lte = function(column, val) {
        return compare.call(this, column, val, function(val, v) {
          return v <= val;
        });
      };
      value.match = function(params) {
        var args, v;
        args = Array.prototype.slice.call(arguments);
        if (args.length > 1 && typeof args[0] === 'string') {
          params = {};
          while (args.length >= 2) {
            params[args.shift()] = args.shift();
          }
        }
        v = this.values().filter(function(row) {
          var e, key, r, reg, test, val;
          for (key in params) {
            if (!__hasProp.call(params, key)) continue;
            val = params[key];
            test = function(row_val) {
              return val === row_val;
            };
            if (!val) {
              test = function(row_val) {
                return !row_val;
              };
            }
            if (typeof val === 'string' && (r = val.match(/^\/(.+)\/$/))) {
              try {
                reg = new RegExp(r[1]);
                test = function(row_val) {
                  return reg.test(val);
                };
              } catch (_error) {
                e = _error;
                return false;
              }
            }
            if (!test(row[key])) {
              return false;
            }
          }
          return true;
        });
        return v;
      };
      return value;
    };
    bind_iterable = function(value) {
      value.get = function() {
        var args, r;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        args = args.join('.');
        r = getColumn(this, args);
        if (Array.isArray(r)) {
          r = bind_array(r);
        }
        return r;
      };
      value.set = function(col, val) {
        return setColumn(this, col, val);
      };
      return value.del = function(col) {
        return deleteColumn(this, col);
      };
    };
    traverse(data).forEach(function(value) {
      var type, _ref1, _ref2;
      type = Object.prototype.toString.call(value).slice(8, -1);
      if (((value != null ? value.isURL : void 0) != null) || (((_ref1 = this.parent) != null ? (_ref2 = _ref1.node) != null ? _ref2.isURL : void 0 : void 0) != null)) {
        console.log('skip isURL');
        return;
      }
      if (type === 'Array') {
        this.update(bind_array(value));
      }
      if (type === 'Object' || type === 'Array') {
        return this.update(bind_iterable(value));
      }
    });
    fn = function(acc, x) {
      if (this.isLeaf && typeof x === 'string') {
        acc.push({
          path: this.path,
          value: x
        });
      }
      return acc;
    };
    return data;
  };

}).call(this);

/*
//@ sourceMappingURL=bind_functions.map
*/
