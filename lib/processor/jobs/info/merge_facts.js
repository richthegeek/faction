// Generated by CoffeeScript 1.6.3
(function() {
  var deleteColumn, getColumn, setColumn, traverse, xtend, _ref;

  xtend = require('xtend');

  traverse = require('traverse');

  _ref = require('./column_ops'), getColumn = _ref.getColumn, setColumn = _ref.setColumn, deleteColumn = _ref.deleteColumn;

  module.exports = function(settings, old_fact, mid_fact) {
    var a, b, field, k, key, list, mode, n_f, new_fact, o_f, old_value, orig, sets, v, val, value, _base, _base1, _base2, _ref1;
    if (old_fact == null) {
      old_fact = {};
    }
    if (mid_fact == null) {
      mid_fact = {};
    }
    new_fact = xtend(old_fact, mid_fact);
    sets = {};
    if (settings.time == null) {
      settings.time = new Date;
    }
    _ref1 = settings.field_modes;
    for (field in _ref1) {
      mode = _ref1[field];
      if (!(value = mid_fact[field])) {
        continue;
      }
      if (mode["eval"]) {
        continue;
      }
      old_value = old_fact[field];
      if (mode === 'all') {
        orig = old_value || [];
        if (!Array.isArray(orig)) {
          orig = [];
        }
        list = orig.concat(value);
        for (k in list) {
          v = list[k];
          if (!v._time) {
            list[k] = {
              _time: settings.time,
              _value: v
            };
          }
        }
        if (sets.$push == null) {
          sets.$push = {};
        }
        if ((_base = sets.$push)[field] == null) {
          _base[field] = {
            $each: []
          };
        }
        sets.$push[field].$each.push({
          _time: settings.time,
          _value: value
        });
        setColumn(new_fact, field, list.filter(function(v) {
          return !!v;
        }));
      }
      if (mode === 'oldest') {
        if (typeof old_value === 'undefined') {
          if (sets.$set == null) {
            sets.$set = {};
          }
          sets.$set[field] = value;
        }
        setColumn(new_fact, field, old_value != null ? old_value : value);
      }
      if (mode === 'min' || mode === 'max') {
        value = Math[mode].apply(null, [value, old_value].map(Number).filter(function(x) {
          return !isNaN(x);
        }));
        if (sets.$set == null) {
          sets.$set = {};
        }
        sets.$set[field] = value;
        setColumn(new_fact, field, value);
      }
      if (mode === 'inc') {
        a = Number(value) || 1;
        b = Number(old_value) || 0;
        if (sets.$inc == null) {
          sets.$inc = {};
        }
        sets.$inc[field] = a;
        setColumn(new_fact, field, a + b);
      }
      if (mode === 'push') {
        orig = old_value || [];
        if (!Array.isArray(orig)) {
          orig = [];
        }
        list = orig.concat(value);
        if (sets.$push == null) {
          sets.$push = {};
        }
        if ((_base1 = sets.$push)[field] == null) {
          _base1[field] = {
            $each: []
          };
        }
        sets.$push[field].$each.push(value);
      }
      if (mode === 'push_unique') {
        if (sets.$addToSet == null) {
          sets.$addToSet = {};
        }
        if ((_base2 = sets.$addToSet)[field] == null) {
          _base2[field] = {
            $each: []
          };
        }
        sets.$addToSet[field].$each.push(value);
      }
    }
    n_f = traverse(new_fact);
    o_f = traverse(old_fact);
    n_f.paths().forEach(function(path) {
      var inc_by, key, new_val, old_val, sub_path, _ref2;
      key = path[path.length - 1];
      if (!key || ((_ref2 = key.charAt(0)) !== '$' && _ref2 !== '%')) {
        return;
      }
      sub_path = path.slice(0, -1);
      new_val = n_f.get(path);
      new_val = new_val[key] || new_val;
      old_val = o_f.get(sub_path);
      if (key === '$inc' || key === '%inc') {
        inc_by = Number(new_val) | 0;
        old_val = old_val | 0;
        return n_f.set(sub_path, old_val + inc_by);
      }
    });
    for (key in new_fact) {
      val = new_fact[key];
      if (!(key.indexOf('.') >= 0)) {
        continue;
      }
      delete new_fact[key];
      setColumn(new_fact, key, val);
    }
    return {
      fact: new_fact,
      updates: sets
    };
  };

}).call(this);

/*
//@ sourceMappingURL=merge_facts.map
*/
