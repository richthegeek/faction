// Generated by CoffeeScript 1.6.3
(function() {
  var deleteColumn, getColumn, setColumn, traverse, xtend, _ref;

  xtend = require('xtend');

  traverse = require('traverse');

  _ref = require('./column_ops'), getColumn = _ref.getColumn, setColumn = _ref.setColumn, deleteColumn = _ref.deleteColumn;

  module.exports = function(settings, old_fact, mid_fact) {
    var a, b, field, formats, k, key, list, mode, moment, new_fact, old_value, orig, sets, v, val, value, _ref1;
    if (settings.time == null) {
      settings.time = new Date;
    }
    if (old_fact == null) {
      old_fact = {};
    }
    if (mid_fact == null) {
      mid_fact = {};
    }
    sets = {};
    for (key in mid_fact) {
      val = mid_fact[key];
      if (((old_fact != null ? old_fact[key] : void 0) != null) && old_fact[key] === mid_fact[key]) {
        continue;
      }
      sets[key] = {
        type: '$set',
        value: val
      };
    }
    new_fact = xtend(old_fact, mid_fact);
    _ref1 = settings.field_modes;
    for (field in _ref1) {
      mode = _ref1[field];
      if (mode["eval"]) {
        continue;
      }
      value = mid_fact[field];
      old_value = old_fact[field];
      delete sets[field];
      switch (mode) {
        case 'inc':
          a = Number(value) || 1;
          b = Number(old_value) || 0;
          sets[field] = {
            type: '$inc',
            value: a
          };
          break;
        case 'inc_day':
        case 'inc_week':
        case 'inc_month':
        case 'inc_year':
          moment = require('moment');
          formats = {
            inc_day: 'YYYY-MM-DD',
            inc_week: 'YYYY-WW',
            inc_month: 'YYYY-MM',
            inc_year: 'YYYY'
          };
          key = moment().format(formats[mode]);
          sets[field + '.' + key] = {
            type: '$inc',
            value: 1
          };
      }
      if (!value) {
        continue;
      }
      switch (mode) {
        case 'inc_map':
          value = value.replace(/\./g, '%2E');
          sets[field + '.' + value] = {
            type: '$inc',
            value: 1
          };
          break;
        case 'all':
          orig = old_value || [];
          if (!Array.isArray(orig)) {
            orig = [];
          }
          list = orig.concat(value);
          for (k in list) {
            v = list[k];
            if (!v._time) {
              list[k] = {
                _time: settings.time,
                _value: v
              };
            }
          }
          sets[field] = {
            type: '$push',
            value: {
              _time: settings.time,
              _value: value
            }
          };
          break;
        case 'oldest':
          if (typeof old_value === 'undefined') {
            if (sets.$set == null) {
              sets.$set = {};
            }
            sets.$set[field] = value;
            sets[field] = {
              type: '$set',
              value: value
            };
          }
          break;
        case 'min':
        case 'max':
          value = Math[mode].apply(null, [value, old_value].map(Number).filter(function(x) {
            return !isNaN(x);
          }));
          sets[field] = {
            type: '$set',
            value: value
          };
          break;
        case 'push':
          orig = old_value || [];
          if (!Array.isArray(orig)) {
            orig = [];
          }
          list = orig.concat(value);
          sets[field] = {
            type: '$push',
            value: value
          };
          break;
        case 'push_unique':
          sets[field] = {
            type: '$addToSet',
            value: value
          };
      }
    }
    return {
      fact: new_fact,
      updates: sets
    };
  };

}).call(this);

/*
//@ sourceMappingURL=merge_facts.map
*/
