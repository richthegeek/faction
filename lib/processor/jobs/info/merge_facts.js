// Generated by CoffeeScript 1.6.3
(function() {
  var deleteColumn, getColumn, setColumn, traverse, xtend, _ref;

  xtend = require('xtend');

  traverse = require('traverse');

  _ref = require('./column_ops'), getColumn = _ref.getColumn, setColumn = _ref.setColumn, deleteColumn = _ref.deleteColumn;

  module.exports = function(settings, old_fact, mid_fact) {
    var a, b, field, k, key, list, mode, n_f, new_fact, o_f, orig, v, val, _ref1, _ref2;
    if (old_fact == null) {
      old_fact = {};
    }
    if (mid_fact == null) {
      mid_fact = {};
    }
    new_fact = xtend(old_fact, mid_fact);
    _ref1 = settings.field_modes;
    for (field in _ref1) {
      mode = _ref1[field];
      if (!mid_fact[field]) {
        continue;
      }
      if (mode["eval"]) {
        continue;
      }
      if (mode === 'all') {
        orig = old_fact[field] || [];
        if (!Array.isArray(orig)) {
          orig = [];
        }
        list = orig.concat(mid_fact[field]);
        for (k in list) {
          v = list[k];
          if (!v._time) {
            list[k] = {
              _time: settings.time || new Date,
              _value: v
            };
          }
        }
        setColumn(new_fact, field, list.filter(function(v) {
          return !!v;
        }));
      }
      if (mode === 'oldest') {
        setColumn(new_fact, field, (_ref2 = old_fact[field]) != null ? _ref2 : mid_fact[field]);
      }
      if (mode === 'min') {
        a = Number(mid_fact[field]) || Math.min();
        b = Number(old_fact[field]) || Math.min();
        setColumn(new_fact, field, Math.min(a, b));
      }
      if (mode === 'max') {
        a = Number(mid_fact[field]) || Math.max();
        b = Number(old_fact[field]) || Math.max();
        setColumn(new_fact, field, Math.max(a, b));
      }
    }
    n_f = traverse(new_fact);
    o_f = traverse(old_fact);
    n_f.paths().forEach(function(path) {
      var inc_by, key, new_val, old_val, sub_path, val, _i, _len, _ref3;
      key = path[path.length - 1];
      sub_path = path.slice(0, -1);
      new_val = n_f.get(path);
      old_val = o_f.get(sub_path);
      if ((_ref3 = key.charAt(0)) !== '$' && _ref3 !== '_') {
        return;
      }
      console.log(key, sub_path, old_val, new_val);
      if (key === '$inc' || key === '_inc') {
        inc_by = Number(new_val) | 0;
        old_val = old_val | 0;
        return n_f.set(sub_path, old_val + inc_by);
      } else if (key === '_addToSet') {
        old_val = [].concat(old_val);
        for (_i = 0, _len = old_val.length; _i < _len; _i++) {
          val = old_val[_i];
          if (val === new_val) {
            return;
          }
        }
        return n_f.set(sub_path, old_val.concat(new_val));
      } else if (key === '_push') {
        old_val = [].concat(old_val);
        return n_f.set(sub_path, old_val.concat(new_val));
      }
    });
    for (key in new_fact) {
      val = new_fact[key];
      if (!(key.indexOf('.') >= 0)) {
        continue;
      }
      delete new_fact[key];
      setColumn(new_fact, key, val);
    }
    return new_fact;
  };

}).call(this);

/*
//@ sourceMappingURL=merge_facts.map
*/
