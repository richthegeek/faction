// Generated by CoffeeScript 1.6.3
(function() {
  var deleteColumn, getColumn, setColumn, traverse, xtend, _ref;

  xtend = require('xtend');

  traverse = require('traverse');

  _ref = require('./column_ops'), getColumn = _ref.getColumn, setColumn = _ref.setColumn, deleteColumn = _ref.deleteColumn;

  module.exports = function(settings, old_fact, mid_fact) {
    var a, b, field, k, key, list, mode, n_f, new_fact, o_f, orig, v, val, _ref1, _ref2;
    if (old_fact == null) {
      old_fact = {};
    }
    if (mid_fact == null) {
      mid_fact = {};
    }
    new_fact = xtend(old_fact, mid_fact);
    _ref1 = settings.field_modes;
    for (field in _ref1) {
      mode = _ref1[field];
      if (!mid_fact[field]) {
        continue;
      }
      if (mode["eval"]) {
        continue;
      }
      if (mode === 'all') {
        orig = old_fact[field] || [];
        if (!Array.isArray(orig)) {
          orig = [];
        }
        list = orig.concat(mid_fact[field]);
        for (k in list) {
          v = list[k];
          if (!v._time) {
            list[k] = {
              _time: settings.time || new Date,
              _value: v
            };
          }
        }
        setColumn(new_fact, field, list.filter(function(v) {
          return !!v;
        }));
      }
      if (mode === 'oldest') {
        setColumn(new_fact, field, (_ref2 = old_fact[field]) != null ? _ref2 : mid_fact[field]);
      }
      if (mode === 'min') {
        a = Number(mid_fact[field]) || Math.min();
        b = Number(old_fact[field]) || Math.min();
        setColumn(new_fact, field, Math.min(a, b));
      }
      if (mode === 'max') {
        a = Number(mid_fact[field]) || Math.max();
        b = Number(old_fact[field]) || Math.max();
        setColumn(new_fact, field, Math.max(a, b));
      }
    }
    n_f = traverse(new_fact);
    o_f = traverse(old_fact);
    n_f.paths().filter(function(path) {
      return path[path.length - 1] === '$inc';
    }).forEach(function(path) {
      var inc_by, old_val, sub_path;
      sub_path = path.slice(0, -1);
      inc_by = n_f.get(path);
      old_val = o_f.get(sub_path) | 0;
      return n_f.set(sub_path, old_val + inc_by);
    });
    for (key in new_fact) {
      val = new_fact[key];
      if (!(key.indexOf('.') >= 0)) {
        continue;
      }
      delete new_fact[key];
      setColumn(new_fact, key, val);
    }
    return new_fact;
  };

}).call(this);

/*
//@ sourceMappingURL=merge_facts.map
*/
