// Generated by CoffeeScript 1.6.3
(function() {
  var deleteColumn, getColumn, moment, setColumn, xtend, _ref;

  moment = require('moment');

  xtend = require('xtend');

  _ref = require('./column_ops'), getColumn = _ref.getColumn, setColumn = _ref.setColumn, deleteColumn = _ref.deleteColumn;

  module.exports = function(settings, old_fact, mid_fact) {
    var a, b, field, format, formats, k, key, list, mode, new_fact, old_value, orig, sets, v, val, value, _ref1;
    if (settings.time == null) {
      settings.time = new Date;
    }
    if (old_fact == null) {
      old_fact = {};
    }
    if (mid_fact == null) {
      mid_fact = {};
    }
    sets = {};
    for (key in mid_fact) {
      val = mid_fact[key];
      if (((old_fact != null ? old_fact[key] : void 0) != null) && old_fact[key] === mid_fact[key]) {
        continue;
      }
      sets[key] = {
        type: '$set',
        value: val
      };
    }
    new_fact = xtend(old_fact, mid_fact);
    _ref1 = settings.field_modes;
    for (field in _ref1) {
      val = _ref1[field];
      mode = val.mode || val;
      if (mode === 'eval' || val["eval"]) {
        delete sets[field];
        continue;
      }
      value = getColumn(mid_fact, field).shift();
      formats = {
        day: 'YYYY-MM-DD',
        week: 'YYYY-WW',
        month: 'YYYY-MM',
        year: 'YYYY'
      };
      if (format = formats[val.grouping]) {
        if (mode === 'newest' || mode === 'oldest' || mode === 'inc' || mode === 'min' || mode === 'max') {
          delete sets[field];
          field = field + '.' + moment().format(format);
        }
      }
      old_value = getColumn(old_fact, field).shift();
      if (mode === 'inc' && ((mid_fact[field] != null) || val.not_null !== true)) {
        a = Number(value) || 1;
        b = Number(old_value) || 0;
        sets[field] = {
          type: '$inc',
          value: a
        };
      }
      if (!value) {
        continue;
      }
      switch (mode) {
        case 'inc_map':
          value = value.replace(/\./g, '%2E');
          sets[field + '.' + value] = {
            type: '$inc',
            value: 1
          };
          break;
        case 'all':
          orig = old_value || [];
          if (!Array.isArray(orig)) {
            orig = [];
          }
          list = orig.concat(value);
          for (k in list) {
            v = list[k];
            if (!v._time) {
              list[k] = {
                _time: settings.time,
                _value: v
              };
            }
          }
          sets[field] = {
            type: '$push',
            value: {
              _time: settings.time,
              _value: value
            }
          };
          break;
        case 'newest':
          sets[field] = {
            type: '$set',
            value: value
          };
          break;
        case 'oldest':
          if (typeof old_value === 'undefined') {
            sets[field] = {
              type: '$set',
              value: value
            };
          }
          break;
        case 'min':
        case 'max':
          if (value === Math[mode].apply(null, [value, old_value].map(Number).filter(function(x) {
            return !isNaN(x);
          }))) {
            sets[field] = {
              type: '$set',
              value: value
            };
          }
          break;
        case 'push':
          orig = old_value || [];
          if (!Array.isArray(orig)) {
            orig = [];
          }
          list = orig.concat(value);
          sets[field] = {
            type: '$push',
            value: value
          };
          break;
        case 'push_unique':
          sets[field] = {
            type: '$addToSet',
            value: value
          };
      }
    }
    return {
      fact: new_fact,
      updates: sets
    };
  };

}).call(this);

/*
//@ sourceMappingURL=merge_facts.map
*/
