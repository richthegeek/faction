// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, async, path, request;

  path = require('path');

  request = require('request');

  async = require('async');

  Cache = require('shared-cache');

  module.exports = function(job, done) {
    var account, accountID, fns, row, time,
      _this = this;
    account = null;
    accountID = job.data.account;
    time = new Date(parseInt(job.created_at));
    row = job.data.data;
    fns = {};
    fns.account = function(next) {
      return loadAccount(accountID, function(err, acc) {
        account = acc;
        return next(err);
      });
    };
    fns.setup = function(next) {
      if (account.hooks == null) {
        account.hooks = Cache.create('hooks-' + accountID, true, function(key, next) {
          return account.database.collection('hooks').find().toArray(next);
        });
      }
      return next();
    };
    fns.hooks = function(next) {
      return account.hooks.get(function(e, r) {
        return next(e, r);
      });
    };
    fns.fact = function(next) {
      return new Fact_deferred_Model(account, row.fact_type, function() {
        var model;
        model = this;
        return this.load({
          _id: row.fact_id
        }, true, function(err, fact) {
          var _this = this;
          if (fact == null) {
            fact = {};
          }
          if (err || !fact._id) {
            return next(err || 'Bad ID');
          }
          if (fact._updated.toJSON() !== row.version) {
            job.log("Skipped due to invalid version");
            return next("Invalid version");
          }
          return this.addShim(function() {
            return next(null, model);
          });
        });
      });
    };
    return async.series(fns, function(err, results) {
      var hook;
      if (err) {
        return done(err);
      }
      hook = results.hooks.filter(function(hook) {
        return hook.fact_type === row.fact_type && hook.hook_id === row.hook_id;
      }).pop();
      if (!hook) {
        return done('Unknown hook');
      }
      if (!results.fact) {
        console.log('No fact?', accountID, typeof row.fact_id, row.fact_id, row.fact_type);
        return done('Unknown fact');
      }
      try {
        return results.fact.withMap(hook["with"], hook.map, false, function(err, result) {
          var cb, fact, file, hookService;
          fact = JSON.parse(JSON.stringify(result));
          cb = function(err, res, body) {
            return callback(null, {
              hook_id: row.hook_id,
              fact_type: row.fact_type,
              fact_id: fact._id,
              status: res.statusCode,
              body: body,
              time: new Date
            });
          };
          if (hook.type == null) {
            hook.type = 'url';
          }
          file = path.resolve(__dirname, './types') + '/' + hook.type;
          hookService = require(file);
          return hookService.exec(hook, fact, function(err, result) {
            if (err) {
              console.log(JSON.stringify(err));
              return done(err);
            }
            return done(err, result);
          });
        });
      } catch (_error) {
        err = _error;
        console.log('Shit code alert');
        console.log(err.stack || err.message || err);
        console.log(typeof err);
        console.log(((err.then != null) && 'Promise') || (Object.prototype.toString.call(err)));
      }
    });
  };

  module.exports.disabled = true;

  module.exports.concurrency = 5;

}).call(this);
