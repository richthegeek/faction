// Generated by CoffeeScript 1.6.3
(function() {
  var assert, async, copernica;

  assert = require('assert');

  async = require('async');

  copernica = require('../types/copernica');

  suite('copernica', function() {
    var copernicaOptions, ids, waitForId;
    this.timeout(30000);
    copernicaOptions = {
      'credentials': {
        'username': 'j.sanderson@livelinknewmedia.com',
        'password': 'Manch1793!',
        'account': 'Elliot UK'
      },
      'database': 'TestDB',
      'state': {}
    };
    ids = {};
    waitForId = function(id, callback) {
      var fn;
      fn = function() {
        if (ids[id] != null) {
          return callback(ids[id]);
        } else {
          return setTimeout(fn, 250);
        }
      };
      return setTimeout(fn, 250);
    };
    test('can connect to copernica', function(done) {
      var options;
      options = copernicaOptions;
      return new copernica._classes.Copernica_Base(options, function(err, obj) {
        assert.equal(null, err);
        assert.equal(copernicaOptions.database, obj.currentDB.name);
        return done();
      });
    });
    test('can create collection', function(done) {
      var options;
      options = copernicaOptions;
      return new copernica._classes.Copernica_Base(options, function(err, obj) {
        return obj.createCollection('testCollection', function(err, collection) {
          assert.equal(null, err);
          assert.equal('testCollection', collection.name);
          ids['collection'] = collection.id;
          return done();
        });
      });
    });
    test('can add fields to collection', function(done) {
      return waitForId('collection', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Base(options, function(err, obj) {
          options = {
            'id': id,
            'name': 'testField',
            'type': 'text',
            'value': '',
            'display': true,
            'ordered': false,
            'length': 255,
            'textlines': 1,
            'hidden': false,
            'index': true
          };
          return obj.createCollectionField(options, function(err, field) {
            assert.equal(null, err);
            assert.equal(options.name, field.name);
            assert.equal(options.type, field.type);
            assert.equal("" + options.display, field.displayed);
            assert.equal("" + options.ordered, field.ordered);
            assert.equal(options.length, field.length);
            assert.equal(options.textlines, field.lines);
            assert.equal("" + options.hidden, field.hidden);
            return done();
          });
        });
      });
    });
    test('can check collections', function(done) {
      var options;
      options = copernicaOptions;
      return new copernica._classes.Copernica_Base(options, function(err, obj) {
        return obj.getCollections(function(err, collections) {
          var row, _i, _len;
          assert.equal(null, err);
          assert(collections.length > 0);
          for (_i = 0, _len = collections.length; _i < _len; _i++) {
            row = collections[_i];
            if (row.name === 'testCollection') {
              assert.equal('testCollection', row.name);
            }
          }
          return done();
        });
      });
    });
    test('can create profile', function(done) {
      var options;
      options = copernicaOptions;
      return new copernica._classes.Copernica_Profile(options, function(err, obj) {
        options = {
          'user_id': '1',
          'email': 'testUser@trakapo.com'
        };
        return obj._create(options, function(err, profile) {
          var row, _i, _len, _ref;
          assert.equal(null, err);
          assert(profile.fields.pair.length > 0);
          _ref = profile.fields.pair;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            row = _ref[_i];
            switch (row.key) {
              case 'user_id':
                assert.equal(options.user_id, row.value);
                break;
              case 'email':
                assert.equal(options.email, row.value);
            }
          }
          ids['profile'] = profile.id;
          return done();
        });
      });
    });
    test('can update profile', function(done) {
      return waitForId('profile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Profile(options, function(err, obj) {
          options = {
            'name': 'John Doe'
          };
          return obj._update(id, options, function(err, obj) {
            assert.equal(null, err);
            return done();
          });
        });
      });
    });
    test('can search for profile', function(done) {
      return waitForId('profile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Profile(options, function(err, obj) {
          options = {
            'email': 'testUser@trakapo.com'
          };
          return obj._search(options, function(err, results) {
            var pair, row, _i, _j, _len, _len1, _ref;
            assert.equal(null, err);
            assert(results.length > 0);
            for (_i = 0, _len = results.length; _i < _len; _i++) {
              row = results[_i];
              _ref = row.fields.pair;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                pair = _ref[_j];
                if (pair.key === 'email' && pair.value === options.email) {
                  assert(true);
                }
              }
            }
            return done();
          });
        });
      });
    });
    test('can create subprofile', function(done) {
      return waitForId('profile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Subprofile(options, function(err, obj) {
          var fields;
          options = {
            'id': id,
            'collection': {
              'id': ids['collection']
            }
          };
          fields = {
            'testField': 'bar'
          };
          return obj._create(fields, options, function(err, subprofile) {
            var row, _i, _len, _ref;
            assert.equal(null, err);
            assert(subprofile.fields.pair.length > 0);
            _ref = subprofile.fields.pair;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              row = _ref[_i];
              switch (row.key) {
                case 'testField':
                  assert.equal(fields.testField, row.value);
              }
            }
            ids['subprofile'] = subprofile.id;
            return done();
          });
        });
      });
    });
    test('can update subprofile', function(done) {
      return waitForId('subprofile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Subprofile(options, function(err, obj) {
          options = {
            'testField': 'bar'
          };
          return obj._update(id, options, function(err, obj) {
            assert.equal(null, err);
            return done();
          });
        });
      });
    });
    test('can search for subprofile', function(done) {
      return waitForId('subprofile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Subprofile(options, function(err, obj) {
          var fields;
          options = {
            'id': ids['profile'],
            'collection': {
              'id': ids['collection']
            }
          };
          fields = {
            'testField': 'bar'
          };
          return obj._search(fields, options, function(err, results) {
            var pair, row, _i, _j, _len, _len1, _ref;
            assert.equal(null, err);
            assert(results.length > 0);
            for (_i = 0, _len = results.length; _i < _len; _i++) {
              row = results[_i];
              _ref = row.fields.pair;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                pair = _ref[_j];
                if (pair.key === 'testField' && pair.value === fields.testField) {
                  assert(true);
                }
              }
            }
            return done();
          });
        });
      });
    });
    test('can use profile combo method', function(done) {
      return waitForId('profile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Profile(options, function(err, obj) {
          var fieldsToUpdate;
          id = {
            'email': 'testUser@trakapo.com'
          };
          fieldsToUpdate = {
            'user_id': '23'
          };
          return obj.profile(id, fieldsToUpdate, function(err, obj) {
            assert.equal(null, err);
            assert.equal(obj.currentProfile._fields.user_id, fieldsToUpdate.user_id);
            return done();
          });
        });
      });
    });
    test('can use subprofile combo method', function(done) {
      return waitForId('subprofile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Profile(options, function(err, obj) {
          var fieldsToUpdate;
          id = {
            'testField': 'bar'
          };
          fieldsToUpdate = {
            'testField': 'baz'
          };
          options = {
            'collection': {
              'id': ids['collection']
            }
          };
          if (obj.currentProfile == null) {
            obj.currentProfile = {};
          }
          obj.currentProfile.id = ids['profile'];
          return obj.subprofile(id, fieldsToUpdate, options, function(err, obj) {
            assert.equal(null, err);
            assert.equal(obj._fields.testField, fieldsToUpdate.testField);
            ids['delete_subprofile'] = 1;
            return done();
          });
        });
      });
    });
    test('can remove a subprofile', function(done) {
      return waitForId('delete_subprofile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Subprofile(options, function(err, obj) {
          return obj._remove(ids['subprofile'], function(err, obj) {
            assert.equal(null, err);
            return done();
          });
        });
      });
    });
    test('can remove a profile', function(done) {
      return waitForId('profile', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Profile(options, function(err, obj) {
          return obj._remove(id, function(err, obj) {
            assert.equal(null, err);
            return done();
          });
        });
      });
    });
    test('can remove collections', function(done) {
      return waitForId('collection', function(id) {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Base(options, function(err, obj) {
          return obj.removeCollection(id, function(err, obj) {
            assert.equal(null, err);
            return done();
          });
        });
      });
    });
    test('can use setup exported method', function(done) {
      var options;
      options = copernicaOptions;
      return copernica.setup(options, function(err, results, copernica) {
        assert.equal(null, err);
        ids['deleteallcollections'] = 1;
        return done();
      });
    });
    return test('can remove all collections', function(done) {
      return waitForId('deleteallcollections', function() {
        var options;
        options = copernicaOptions;
        return new copernica._classes.Copernica_Base(options, function(err, obj) {
          return obj.getCollections(function(err, results) {
            return async.map(results, (function(collection, next) {
              return obj.removeCollection(collection.id, next);
            }), function(err, results) {
              assert.equal(null, err);
              return done();
            });
          });
        });
      });
    });
  });

}).call(this);
