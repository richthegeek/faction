// Generated by CoffeeScript 1.6.3
(function() {
  var Cache, async, http, q,
    __slice = [].slice;

  http = require('./http');

  q = require('q');

  async = require('async');

  Cache = require('shared-cache');

  module.exports = {
    disabled: false,
    concurrency: 1,
    timeout: 10000,
    exec: function(job, done) {
      var account, accountID, debug, debugMode, fns, row, s, t, time,
        _this = this;
      account = null;
      accountID = job.data.account;
      time = new Date(parseInt(job.created_at));
      row = job.data.data;
      debugMode = false;
      debug = function() {
        if (debugMode) {
          return console.log.apply(console.log, arguments);
        }
      };
      s = +(new Date);
      t = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        args.push((+(new Date)) - s);
        return console.log.apply(console.log, args);
      };
      fns = {};
      fns.account = function(next) {
        return loadAccount(accountID, function(err, acc) {
          account = acc;
          return next(err);
        });
      };
      fns.setup = function(next) {
        if (account.hooks == null) {
          account.hooks = Cache.create('hooks-' + accountID, true, function(key, next) {
            return account.database.collection('hooks').find().toArray(next);
          });
        }
        if (account.settings == null) {
          account.settings = Cache.create('fact-settings-' + accountID, true, function(key, next) {
            return account.database.collection('fact_settings').find().toArray(next);
          });
        }
        if (account.conditions == null) {
          account.conditions = Cache.create('fact-conditions-' + accountID, true, function(key, next) {
            return account.database.collection('conditions').find().toArray(next);
          });
        }
        if (account.actions == null) {
          account.actions = Cache.create('actions-' + accountID, true, function(key, next) {
            return account.database.collection('actions').find().toArray(next);
          });
        }
        return next();
      };
      fns.hooks = function(next) {
        return account.hooks.get(function(e, r) {
          return next(e, r);
        });
      };
      fns.settings = function(next) {
        return account.settings.get(function(e, r) {
          return next(e, r);
        });
      };
      fns.conditions = function(next) {
        return account.conditions.get(function(e, r) {
          return next(e, r);
        });
      };
      fns.actions = function(next) {
        return account.actions.get(function(e, r) {
          return next(e, r);
        });
      };
      fns.fact = function(next) {
        return new Fact_deferred_Model(account, row.fact_type, function() {
          var model;
          model = this;
          return this.load({
            _id: row.fact_id
          }, true, function(err, fact) {
            if (fact == null) {
              fact = {};
            }
            if (err || !fact._id) {
              return next(err || 'Bad ID');
            }
            debugMode = debugMode || fact.data.debug === true;
            if (!fact._updated) {
              return next('No timestamp');
            }
            if (row.version && fact._updated.toJSON() !== row.version) {
              job.log("Skipped due to invalid version");
              return next("Invalid version");
            }
            return next(null, model);
          });
        });
      };
      return async.series(fns, function(err, results) {
        var actions, conditions, context, doConditions, evals, evaluate, fact, filter, hooks, key, props, settings;
        filter = function(obj) {
          return row.fact_type === obj.fact_type;
        };
        hooks = results.hooks.filter(filter);
        conditions = results.conditions.filter(filter);
        actions = results.actions.filter(filter);
        settings = results.settings.filter(function(setting) {
          return setting._id === row.fact_type;
        }).pop() || {};
        if (settings.field_modes == null) {
          settings.field_modes = {};
        }
        if (settings.foreign_keys == null) {
          settings.foreign_keys = {};
        }
        fact = results.fact;
        if (err) {
          if (err === 'Invalid version') {
            err = null;
          }
          return done(err);
        }
        if ((fact != null ? fact.data : void 0) == null) {
          return done('Invalid fact');
        }
        context = {
          http: http,
          q: q,
          fact: fact.data,
          debug: debug,
          load: function(type, id) {
            var defer;
            defer = q.defer();
            new Fact_deferred_Model(account, type, function() {
              return this.load({
                _id: id
              }, function(err, found) {
                if (err || !found) {
                  return defer.reject(err || 'Not found');
                }
                return defer.resolve(this.data);
              });
            });
            return defer.promise;
          }
        };
        evals = (function() {
          var _ref, _results;
          _ref = settings.field_modes;
          _results = [];
          for (key in _ref) {
            props = _ref[key];
            if (props["eval"]) {
              _results.push([key, props]);
            }
          }
          return _results;
        })();
        evaluate = function(arr, next) {
          var _this = this;
          key = arr[0], props = arr[1];
          return fact.withMap([], props.map, context, function(err, map) {
            var k, v, _ref;
            debug('Preval', map);
            for (k in context) {
              v = context[k];
              map[k] = (_ref = map[k]) != null ? _ref : v;
            }
            return fact.data["eval"](props["eval"], map, function(err, result) {
              var _ref1;
              debug('Eval', props["eval"], result);
              result = (_ref1 = result != null ? result : props["default"]) != null ? _ref1 : null;
              fact.data.set.call(fact.data.data, key, result);
              return next(null, {
                key: key,
                value: result
              });
            });
          });
        };
        doConditions = function(condition, next) {
          return fact.evaluateCondition(condition, context, function(err, result) {
            result = !err && result.every(Boolean);
            return next(null, {
              key: '_conditions.' + condition.condition_id,
              value: result
            });
          });
        };
        return async.mapSeries(evals, evaluate, function(err, cols1) {
          return async.mapSeries(conditions, doConditions, function(err, cols2) {
            var col, columns, list, set, _i, _len;
            columns = cols1.concat(cols2).filter(Boolean);
            time = new Date;
            if (columns.length > 0) {
              set = {};
              for (_i = 0, _len = columns.length; _i < _len; _i++) {
                col = columns[_i];
                set[col.key] = col.value;
              }
              set._updated = time;
              fact.table.update({
                _id: fact.data._id
              }, {
                $set: set
              }, function(err) {
                if (err) {
                  return console.error('Fact Update write failure', fact.table.db.databaseName, fact.table.collectionName, fact.data._id, arguments);
                }
              });
            }
            list = hooks.map(function(hook) {
              return jobs.create('hook_send', {
                title: "" + hook.hook_id + " - " + row.fact_type + " - " + row.fact_id,
                account: accountID,
                data: {
                  hook_id: hook.hook_id,
                  fact_type: hook.fact_type,
                  fact_id: fact.data._id,
                  version: time
                }
              });
            });
            list = list.concat(actions.map(function(action) {
              return job = jobs.create('perform_action', {
                title: "" + action.action_id + " - " + row.fact_type + " - " + row.fact_id,
                account: accountID,
                data: {
                  action_id: action.action_id,
                  fact_type: action.fact_type,
                  fact_id: fact.data._id,
                  version: time,
                  stage: -1
                }
              });
            }));
            return async.each(list, (function(job, next) {
              return job.save(next);
            }), function(err) {
              return done(null, columns);
            });
          });
        });
      });
    }
  };

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
