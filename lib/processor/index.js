// Generated by CoffeeScript 1.6.3
(function() {
  var accounts, async, exec, fs, jobsPath, path, processJobs;

  console.log('Starting processor');

  accounts = {};

  global.loadAccount = function(accountID, next) {
    if (accounts[accountID] != null) {
      return next(null, accounts[accountID]);
    }
    return new Account_Model(function() {
      return this.load({
        _id: accountID
      }, function(err, found) {
        var _this = this;
        if (err || !found) {
          return err || 'No such account: ' + accountID;
        }
        return mongodb.open(this.dbname(), null, config.mongo.host, config.mongo.port, function(err, db) {
          accounts[accountID] = _this;
          _this.database = db;
          return next(err, _this);
        });
      });
    });
  };

  jobs.promote();

  async = require('async');

  fs = require('fs');

  path = require('path');

  exec = require('child_process').exec;

  jobsPath = path.resolve(__dirname, './jobs');

  processJobs = function(type, ready) {
    var disabled, idle, jobPath, multi, processor, times;
    jobPath = jobsPath + '/' + type;
    processor = require(jobPath);
    multi = Math.max(processor.concurrency | 0, 1);
    disabled = (processor.disabled !== true) && (processor.concurrency !== 0);
    console.log("Processing " + multi + "x '" + type + "' tasks");
    times = [];
    idle = false;
    setInterval((function() {
      var max, mean, min, pad, sum;
      pad = function(str, size) {
        if (size == null) {
          size = 5;
        }
        str = str.toString();
        while (str.length < size) {
          str = " " + str;
        }
        return str;
      };
      if (times.length > 0) {
        sum = pad(times.reduce(function(a, b) {
          return a + b;
        }));
        max = pad(times.reduce(function(a, b) {
          return Math.max(a, b);
        }));
        min = pad(times.reduce(function(a, b) {
          return Math.min(a, b);
        }));
        mean = pad(Math.round(sum / times.length));
        console.log("+", pad(type, 15), pad(times.length), "" + sum + "ms", [mean, min, max].join(" / "));
        idle = false;
        return times = [];
      } else {
        if (!idle) {
          console.log("`", pad(type, 15), 'idle');
        }
        return idle = true;
      }
    }), config.kue.interval * 1000);
    jobs.process(type, multi, function(job, complete) {
      var start;
      start = new Date;
      return processor(job, function(err, result) {
        var end, time;
        end = new Date;
        time = end - start;
        stats.increment("kue." + type, 1);
        stats.timing("kue." + type, time);
        times.push(time);
        if (err) {
          console.error('!', type, job.data.title, err);
          job.log(err);
        }
        return complete();
      });
    });
    return ready();
  };

  async.each(fs.readdirSync(jobsPath), processJobs);

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
