// Generated by CoffeeScript 1.6.3
var check, crypto, dir, file, files, fn, fs, group, model, name, restify, server, _i, _len, _ref, _ref1, _ref2,
  __slice = [].slice;

fs = require('fs');

restify = require('restify');

crypto = require('crypto');

check = require('validator').check;

global.config = {};

global.config.port = 9876;

global.mongodb = require('./db');

server = restify.createServer();

server.on('uncaughtException', function(req, res, route, err) {
  var _ref;
  if (err.stack && ((_ref = err.name) !== 'ValidatorError')) {
    console.error(err.stack);
  }
  return res.send(500, {
    status: "error",
    statusText: err.message || err
  });
});

server.use(restify.queryParser());

server.use(function(req, res, next) {
  return next(null, req.headers['content-type'] = 'application/json');
});

server.use(restify.bodyParser({
  mapParams: false
}));

server.use(function(req, res, next) {
  req["throw"] = function(err) {
    return server.emit('uncaughtException', req, res, req.route, err);
  };
  req.params.asQuery = function() {
    var allowed, k, name, ret, v, val, _i, _len;
    allowed = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (allowed.length === 0) {
      allowed = (function() {
        var _ref, _results;
        _ref = req.params;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(k);
        }
        return _results;
      })();
    }
    ret = {};
    for (_i = 0, _len = allowed.length; _i < _len; _i++) {
      name = allowed[_i];
      if (!(req.params[name] != null)) {
        continue;
      }
      val = req.params[name];
      if (typeof val !== 'function') {
        name = name.replace(/[^a-z0-9_]+/ig, '_');
        ret[name] = val;
      }
    }
    return ret;
  };
  if (req.route.auth === false) {
    return next();
  }
  check(req.query.key, {
    notNull: 'This route is authorised, but no public key has been provided in the query string.',
    regex: 'The public key provided is not a 32-character hexadecimal string.'
  }).notNull().is(/[a-f0-9]{32}/i);
  check(req.query.hash, {
    notNull: 'This route is authorised, but no request hash has been provided in the query string.',
    regex: 'The HMAC hash provided is not a SHA-256 64-character hexadecimal string.'
  }).notNull().is(/[a-f0-9]{64}/i);
  return new Account_Model(function() {
    var id;
    id = req.query.key.substring(0, 16);
    return this.load({
      _id: id
    }, function(err, loaded) {
      var hash, hash_parts, key, name, _ref;
      try {
        if (!err && loaded) {
          _ref = this.data.keys;
          for (name in _ref) {
            key = _ref[name];
            if (!(key["public"] === req.query.key)) {
              continue;
            }
            req.path = req.url.split('?').shift();
            hash_parts = [];
            hash_parts.push(req.path);
            hash_parts.push(JSON.stringify(req.body || {}));
            hash_parts.push(key["private"]);
            hash = crypto.createHash('sha256').update(hash_parts.join('')).digest('hex');
            if (hash === req.query.hash) {
              req.key = key;
              req.account = this;
              delete req.params.key;
              delete req.params.hash;
              return next();
            }
            throw "Request signature did not match. (path = " + hash_parts[0] + ", body = " + hash_parts[1];
          }
        }
        throw 'Unrecognised public key.';
      } catch (_error) {
        err = _error;
        return server.emit('uncaughtException', req, res, req.route, err);
      }
    });
  });
});

files = {
  models: {},
  routes: {}
};

for (dir in files) {
  _ref = fs.readdirSync(__dirname + '/' + dir);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    file = _ref[_i];
    if (!(file.substr(-3) === '.js')) {
      continue;
    }
    name = file.slice(0, -3);
    files[dir][name] = require(__dirname + '/' + dir + '/' + file);
  }
}

_ref1 = files.models;
for (name in _ref1) {
  model = _ref1[name];
  name = name.slice(0, 1).toUpperCase() + name.slice(1) + '_Model';
  global[name] = model;
}

_ref2 = files.routes;
for (group in _ref2) {
  fn = _ref2[group];
  fn(server);
}

server.listen(config.port);
