// Generated by CoffeeScript 1.6.3
(function() {
  var crypto, dir, file, files, fn, fs, group, model, name, restify, server, _i, _len, _ref, _ref1, _ref2, _ref3,
    __slice = [].slice;

  fs = require('fs');

  global.restify = restify = require('restify');

  crypto = require('crypto');

  global.config = {};

  global.config.port = 9876;

  global.mongodb = require('./db');

  server = restify.createServer({
    formatters: {
      'application/json': function(req, res, body) {
        var data;
        if (body instanceof Error) {
          res.statusCode = body.statusCode || 500;
          if (body.body) {
            body = body.body;
          }
          body = {
            status: 'error',
            statusText: body.message
          };
        } else if (Buffer.isBuffer(body)) {
          body = body.toString('base64');
        } else if (typeof body === 'string') {
          body = {
            status: 'error',
            statusText: body
          };
        }
        data = JSON.stringify(body);
        res.bodyData = data;
        res.setHeader('Content-Length', Buffer.byteLength(data));
        return data;
      }
    }
  });

  global.ErrorHandler = function(next, good) {
    return function(err) {
      if (err) {
        return next(new Error(err));
      } else {
        return next(good.apply(this, arguments));
      }
    };
  };

  server.on('uncaughtException', function(req, res, route, err) {
    console.error(err.stack);
    return res.send(500, {
      status: "error",
      statusText: err.message || err
    });
  });

  server.on('NotFound', function(req, res, next) {
    return next(res.send(404, {
      status: 'error',
      statusText: 'Endpoint not found'
    }));
  });

  server.on('MethodNotAllowed', function(req, res, next) {
    return next(res.send(404, {
      status: 'error',
      statusText: 'Endpoint not found'
    }));
  });

  server.on('VersionNotAllowed', function(req, res, next) {
    return next(res.send(404, {
      status: 'error',
      statusText: 'Endpoint not found'
    }));
  });

  server.on('after', function(req, res, route, err) {
    var time, _base;
    time = new Date - res._time;
    if (req.route == null) {
      req.route = {};
    }
    if ((_base = req.route).path == null) {
      _base.path = req._path;
    }
    console.log("" + req.method + " " + req.route.path + " (" + time + "ms): " + res.statusCode);
    if (res.statusCode.toString().slice(0, 1) !== '2') {
      return console.error(res.bodyData);
    }
  });

  server.use(function(req, res, next) {
    req.logTime = req.logTime = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      args.unshift((+(new Date)) - req.time());
      return console.log.apply(console.log, args);
    };
    return next();
  });

  server.use(function(rq, rs, n) {
    return next(null, req.logTime('pre-QueryParser'));
  });

  server.use(restify.queryParser());

  server.use(function(rq, rs, n) {
    return next(null, req.logTime('post-QueryParser'));
  });

  server.use(function(req, res, next) {
    return next(null, req.headers['content-type'] = 'application/json');
  });

  server.use(function(rq, rs, n) {
    return next(null, req.logTime('post-header'));
  });

  server.use(restify.bodyParser({
    mapParams: false,
    requestBodyOnGet: true
  }));

  server.use(function(rq, rs, n) {
    return next(null, req.logTime('post-bodyParser'));
  });

  server.use(function(req, res, next) {
    if (req.method === 'GET' && req.params.body) {
      req.body = JSON.parse(req.params.body);
    }
    req.logTime('post req.body parse');
    return next();
  });

  server.use(function(req, res, next) {
    res.notFound = function(noun) {
      return this.send(404, {
        status: 'error',
        statusText: "There was no " + noun + " found matching those parameters"
      });
    };
    req.params.asQuery = function() {
      var allowed, k, name, ret, v, val, _i, _len;
      allowed = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (allowed.length === 0) {
        allowed = (function() {
          var _ref, _results;
          _ref = req.params;
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            _results.push(k);
          }
          return _results;
        })();
      }
      ret = {};
      for (_i = 0, _len = allowed.length; _i < _len; _i++) {
        name = allowed[_i];
        if (!((req.params[name] != null) && name !== 'body')) {
          continue;
        }
        val = req.params[name];
        if (typeof val !== 'function') {
          name = name.replace(/[^a-z0-9_]+/ig, '_');
          ret[name] = val;
        }
      }
      return ret;
    };
    req.logTime('preAuth');
    return next();
  });

  files = {
    models: {},
    routes: {},
    auth: {}
  };

  for (dir in files) {
    _ref = fs.readdirSync(__dirname + '/' + dir);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (!(file.substr(-3) === '.js')) {
        continue;
      }
      name = file.slice(0, -3);
      files[dir][name] = require(__dirname + '/' + dir + '/' + file);
    }
  }

  global.Auth = {};

  _ref1 = files.auth;
  for (name in _ref1) {
    fn = _ref1[name];
    Auth[name] = fn;
    server.use(Auth[name]);
  }

  _ref2 = files.models;
  for (name in _ref2) {
    model = _ref2[name];
    name = name.slice(0, 1).toUpperCase() + name.slice(1) + '_Model';
    global[name] = model;
  }

  _ref3 = files.routes;
  for (group in _ref3) {
    fn = _ref3[group];
    fn(server);
  }

  console.log('Listening on', config.port);

  server.listen(config.port);

}).call(this);
