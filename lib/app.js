// Generated by CoffeeScript 1.6.3
var crypto, dir, file, files, fn, fs, group, model, name, restify, server, _i, _len, _ref, _ref1, _ref2,
  __slice = [].slice;

fs = require('fs');

restify = require('restify');

crypto = require('crypto');

global.config = {};

global.config.port = 9876;

global.mongodb = require('./db');

server = restify.createServer({
  formatters: {
    'application/json': function(req, res, body) {
      var data;
      if (body instanceof Error) {
        res.statusCode = body.statusCode || 500;
        if (body.body) {
          body = body.body;
        }
        body = {
          status: 'error',
          statusText: body.message
        };
      } else if (Buffer.isBuffer(body)) {
        body = body.toString('base64');
      } else if (typeof body === 'string') {
        body = {
          status: 'error',
          statusText: body
        };
      }
      data = JSON.stringify(body);
      res.setHeader('Content-Length', Buffer.byteLength(data));
      return data;
    }
  }
});

global.ErrorHandler = function(next, good) {
  return function(err) {
    if (err) {
      return next(new Error(err));
    } else {
      return next(good.apply(this, arguments));
    }
  };
};

global.error = function(message) {
  return {
    status: 'error',
    statusText: message
  };
};

server.on('uncaughtException', function(req, res, route, err) {
  console.error(err.stack);
  return res.send(500, {
    status: "error",
    statusText: err.message || err
  });
});

server.on('NotFound', function(req, res, next) {
  return res.send(404, {
    status: 'error',
    statusText: 'Endpoint not found'
  });
});

server.on('MethodNotAllowed', function(req, res, next) {
  return res.send(404, {
    status: 'error',
    statusText: 'Endpoint not found'
  });
});

server.on('VersionNotAllowed', function(req, res, next) {
  return res.send(404, {
    status: 'error',
    statusText: 'Endpoint not found'
  });
});

server.on('after', function(req, res, route, err) {
  var time;
  time = new Date - res._time;
  return console.log("" + req.method + " " + req.route.path + " (" + time + "ms): " + res.statusCode);
});

server.use(restify.queryParser());

server.use(function(req, res, next) {
  return next(null, req.headers['content-type'] = 'application/json');
});

server.use(restify.bodyParser({
  mapParams: false,
  requestBodyOnGet: true
}));

server.use(function(req, res, next) {
  if (req.method === 'GET' && req.params.body) {
    req.body = JSON.parse(req.params.body);
  }
  return next();
});

server.use(function(req, res, next) {
  res.notFound = function(noun) {
    return this.send(404, {
      status: 'error',
      statusText: "Their was no " + noun + " found matching those parameters"
    });
  };
  req["throw"] = function(err) {
    return server.emit('uncaughtException', req, res, req.route, err);
  };
  req.params.asQuery = function() {
    var allowed, k, name, ret, v, val, _i, _len;
    allowed = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (allowed.length === 0) {
      allowed = (function() {
        var _ref, _results;
        _ref = req.params;
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(k);
        }
        return _results;
      })();
    }
    ret = {};
    for (_i = 0, _len = allowed.length; _i < _len; _i++) {
      name = allowed[_i];
      if (!(req.params[name] != null)) {
        continue;
      }
      val = req.params[name];
      if (typeof val !== 'function') {
        name = name.replace(/[^a-z0-9_]+/ig, '_');
        ret[name] = val;
      }
    }
    return ret;
  };
  return next();
});

server.use(function(req, res, next) {
  if (req.route.auth === false) {
    return next();
  }
  if (!req.query.key || !req.query.key.toString().match(/^[a-f0-9]{32}$/i)) {
    return next(new restify.InvalidCredentialsError('This route is authorised, but no public key has been provided in the query string.'));
  }
  if (!req.query.hash || !req.query.hash.toString().match(/^[a-f0-9]{64}$/i)) {
    return next(new restify.InvalidCredentialsError('This route is authorised, but no request hash been provided in the query string.'));
  }
  return new Account_Model(function() {
    var id;
    id = req.query.key.substring(0, 16);
    return this.load({
      _id: id
    }, function(err, loaded) {
      var hash, hash_parts, key, name, regex, text, _ref;
      try {
        if (err || !loaded) {
          throw 'Unrecognised public key.';
        }
        _ref = this.data.keys;
        for (name in _ref) {
          key = _ref[name];
          if (!(key["public"] === req.query.key)) {
            continue;
          }
          req.path = req.url.split('?').shift();
          hash_parts = [];
          hash_parts.push(req.path);
          hash_parts.push(JSON.stringify(req.body || {}));
          hash_parts.push(key["private"]);
          hash = crypto.createHash('sha256').update(hash_parts.join('')).digest('hex');
          if ((key.secure === false) || (hash === req.query.hash)) {
            if (key.secure === false) {
              console.log('Bypassing security');
            }
            req.key = key;
            req.account = this;
            delete req.params.key;
            delete req.params.hash;
            text = req.method.toUpperCase() + ' ' + req.path;
            while (key.parent) {
              key.endpoints = [].concat(key.endpoints);
              if (key.endpoints.length > 0 && ((function() {
                var _i, _len, _ref1, _results;
                _ref1 = key.endpoints;
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  regex = _ref1[_i];
                  if (new RegExp('^' + regex).test(text)) {
                    _results.push(1);
                  }
                }
                return _results;
              })()).length === 0) {
                throw "Request is not allowed using this key due to endpoint restriction.";
              }
              key = req.account.data.keys[key.parent] || {
                parent: null
              };
            }
            return next();
          }
          throw "Request signature did not match. (path = " + hash_parts[0] + ", body = " + hash_parts[1];
        }
      } catch (_error) {
        err = _error;
        return server.emit('uncaughtException', req, res, req.route, err);
      }
    });
  });
});

files = {
  models: {},
  routes: {}
};

for (dir in files) {
  _ref = fs.readdirSync(__dirname + '/' + dir);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    file = _ref[_i];
    if (!(file.substr(-3) === '.js')) {
      continue;
    }
    name = file.slice(0, -3);
    files[dir][name] = require(__dirname + '/' + dir + '/' + file);
  }
}

_ref1 = files.models;
for (name in _ref1) {
  model = _ref1[name];
  name = name.slice(0, 1).toUpperCase() + name.slice(1) + '_Model';
  global[name] = model;
}

_ref2 = files.routes;
for (group in _ref2) {
  fn = _ref2[group];
  fn(server);
}

console.log('Listening on', config.port);

server.listen(config.port);
