// Generated by CoffeeScript 1.6.3
(function() {
  var dir, file, files, fn, fs, group, logTime, name, server, _i, _len, _ref,
    __slice = [].slice;

  global.restify = require('restify');

  server = restify.createServer({
    formatters: {
      'application/json': function(req, res, body) {
        var data;
        if (body instanceof Error) {
          res.statusCode = body.statusCode || 500;
          if (body.body) {
            body = body.body;
          }
          body = {
            status: 'error',
            statusText: body.message
          };
        } else if (Buffer.isBuffer(body)) {
          body = body.toString('base64');
        } else if (typeof body === 'string') {
          body = {
            status: 'error',
            statusText: body
          };
        }
        data = JSON.stringify(body);
        res.bodyData = data;
        res.setHeader('Content-Length', Buffer.byteLength(data));
        return data;
      }
    }
  });

  global.ErrorHandler = function(next, good) {
    return function(err) {
      if (err) {
        return next(new Error(err));
      }
      return next(good.apply(this, arguments));
    };
  };

  server.on('uncaughtException', function(req, res, route, err) {
    return res.send(500, {
      status: "error",
      statusText: err.message || err
    });
  });

  server.on('NotFound', function(req, res, next) {
    return next(res.send(404, {
      status: 'error',
      statusText: 'Endpoint not found'
    }));
  });

  server.on('MethodNotAllowed', function(req, res, next) {
    return next(res.send(404, {
      status: 'error',
      statusText: 'Endpoint not found'
    }));
  });

  server.on('VersionNotAllowed', function(req, res, next) {
    return next(res.send(404, {
      status: 'error',
      statusText: 'Endpoint not found'
    }));
  });

  server.on('after', function(req, res, route, err) {
    var nice_path, time, _base, _ref;
    if (req.suppressLog || res.suppressLog) {
      return;
    }
    time = new Date - res._time;
    if (req.route == null) {
      req.route = {};
    }
    if ((_base = req.route).path == null) {
      _base.path = (_ref = req._path) != null ? _ref : '/';
    }
    if (res.logMessage == null) {
      res.logMessage = '';
    }
    console.log("" + req.method + " " + req.route.path + " (" + time + "ms): " + res.statusCode + " " + res.logMessage);
    nice_path = req.route.path.slice(1).replace(/[^a-z0-9_]+/g, '_');
    if (nice_path === '') {
      nice_path = 'frontpage';
    }
    if (res.statusCode.toString().slice(0, 1) !== '2') {
      if (0 > res.bodyData.indexOf('"Endpoint not found"')) {
        return console.error(res.bodyData);
      }
    }
  });

  server.use(restify.CORS());

  server.use(restify.fullResponse());

  server.use(function(req, res, next) {
    req.canary = true;
    req.tempID = (Math.round(Math.random() * 99999)).toString();
    req.logTime = req.logTime = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (req.canary) {
        args.unshift((Date.now() - req.time()) + 'ms');
        args.unshift(req.tempID);
        return console.log.apply(console.log, args);
      }
    };
    return next();
  });

  logTime = function(name) {
    return function(req, res, next) {
      req.logTime(name);
      return next();
    };
  };

  server.use(logTime('start'));

  server.use(restify.queryParser());

  server.use(logTime('queryParser'));

  server.use(function(req, res, next) {
    return next(null, req.headers['content-type'] = 'application/json');
  });

  server.use(logTime('force JSON'));

  server.use(restify.bodyParser({
    mapParams: false,
    requestBodyOnGet: true
  }));

  server.use(logTime('bodyParser'));

  server.use(function(req, res, next) {
    if (req.method === 'GET' && req.params.body) {
      req.body = JSON.parse(req.params.body);
      if (typeof req.body === 'string') {
        req.body = JSON.parse(req.body);
      }
    }
    return next();
  });

  server.use(logTime('force body on GET'));

  server.use(function(req, res, next) {
    res.notFound = function(noun) {
      return this.send(404, {
        status: 'error',
        statusText: "There was no " + noun + " found matching those parameters"
      });
    };
    req.params.asQuery = function() {
      var allowed, k, name, ret, v, val, _i, _len;
      allowed = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (allowed.length === 0) {
        allowed = (function() {
          var _ref, _results;
          _ref = req.params;
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            _results.push(k);
          }
          return _results;
        })();
      }
      ret = {};
      for (_i = 0, _len = allowed.length; _i < _len; _i++) {
        name = allowed[_i];
        if (!((req.params[name] != null) && name !== 'body')) {
          continue;
        }
        val = req.params[name];
        if (typeof val !== 'function') {
          name = name.replace(/[^a-z0-9_]+/ig, '_');
          ret[name] = val;
        }
      }
      return ret;
    };
    return next();
  });

  server.use(logTime('helpers'));

  fs = require('fs');

  files = {
    routes: {},
    auth: {}
  };

  for (dir in files) {
    _ref = fs.readdirSync(__dirname + '/' + dir);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (!(file.substr(-3) === '.js')) {
        continue;
      }
      name = file.slice(0, -3);
      files[dir][name] = require(__dirname + '/' + dir + '/' + file);
    }
  }

  global.Auth = files.auth;

  global.Routes = files.routes;

  for (name in Auth) {
    fn = Auth[name];
    server.use(Auth[name]);
  }

  server.use(logTime('auth'));

  server.use(function(req, res, next) {
    var recurse;
    recurse = function(obj) {
      var date, key, keys, _j, _len1;
      if (obj && typeof obj === 'object') {
        try {
          keys = Object.keys(obj);
          for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
            key = keys[_j];
            obj[key] = recurse(obj[key]);
          }
        } catch (_error) {}
      }
      if (typeof obj === 'string') {
        if (obj.match(/^[0-9]{4}-(0?[0-9]|1[12])-[0-9]/)) {
          date = Date.parse(obj);
          if (!isNaN(date)) {
            obj = new Date(date);
          }
        }
      }
      return obj;
    };
    recurse(req.body);
    return next();
  });

  server.use(logTime('parse dates'));

  for (group in Routes) {
    fn = Routes[group];
    fn(server);
  }

  server.use(logTime('routes'));

  console.log('Listening on', config.api.port);

  server.listen(config.api.port);

}).call(this);

/*
//@ sourceMappingURL=index.map
*/
