// Generated by CoffeeScript 1.6.3
(function() {
  var async;

  async = require('async');

  module.exports = function(server) {
    server.get('/export', Factsettings_Model.route, function(req, res, next) {
      var cols, db;
      db = req.model.db;
      cols = ['info_mappings', 'fact_settings', 'hooks'].filter(function(v) {
        return req.body[v] !== false;
      });
      return async.map(cols, function(name, next) {
        return db.collection(name).find(function(err, cursor) {
          return cursor.toArray(function(err, res) {
            return next(err, [name, res]);
          });
        });
      }, function(err, results) {
        var output, row, _i, _len;
        output = {};
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          row = results[_i];
          output[row[0]] = row[1].map(function(el) {
            if (row[0] !== 'fact_settings') {
              delete el._id;
            }
            return el;
          });
        }
        output = JSON.stringify(output);
        res.header('Content-Description', 'File Transfer');
        res.header('Content-Type', 'application/javascript');
        res.header('Content-Disposition', 'attachment; filename=faction-export.json');
        res.header('Content-Length', output.length);
        res.write(output);
        res.end();
        return next();
      });
    });
    return server.post('/import', Factsettings_Model.route, function(req, res, next) {
      var data, db, entry, _i, _j, _len, _len1, _ref, _ref1;
      db = req.model.db;
      data = [];
      if (req.body.fact_settings) {
        data.push(['fact_settings', req.body.fact_settings]);
      }
      if (req.body.info_mappings) {
        data.push(['info_mappings', req.body.info_mappings]);
        _ref = req.body.info_mappings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entry = _ref[_i];
          if (!entry.mapping_id) {
            return next(new restify.InvalidArgumentError('Info mappings must have a mapping_id'));
          }
          if (!entry.fact_type) {
            return next(new restify.InvalidArgumentError('Info mappings must have a fact_type'));
          }
          if (!entry.fact_identifier) {
            return next(new restify.InvalidArgumentError('Info mappings must have a fact_identifier'));
          }
          if (!entry.info_type) {
            return next(new restify.InvalidArgumentError('Info mappings must have a info_type'));
          }
        }
      }
      if (req.body.hooks) {
        data.push(['hooks', req.body.hooks]);
        _ref1 = req.body.hooks;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          entry = _ref1[_j];
          if (!entry.hook_id) {
            return next(new restify.InvalidArgumentError('Hooks must have a hook_id'));
          }
          if (!entry.fact_type) {
            return next(new restify.InvalidArgumentError('Hooks must have a fact_type'));
          }
          if (!entry.type) {
            return next(new restify.InvalidArgumentError('Hooks must have a type'));
          }
        }
      }
      return async.map(data, function(row, next) {
        var collection, entries, name;
        name = row[0], entries = row[1];
        collection = db.collection(name);
        return collection.remove(function(err) {
          if (err) {
            return next(err);
          }
          return async.map(entries, collection.insert.bind(collection), next);
        });
      }, function(err, result) {
        return next(res.send(arguments));
      });
    });
  };

}).call(this);

/*
//@ sourceMappingURL=io.map
*/
