// Generated by CoffeeScript 1.6.3
var async;

async = require('async');

module.exports = function(server) {
  server.get('/facts', function(req, res, next) {
    return Fact_Model.getTypes(req.account, ErrorHandler(next, function(err, types) {
      return types.detailed(ErrorHandler(next, function(err, info) {
        return res.send(info);
      }));
    }));
  });
  server.get('/facts/:fact-type', Fact_Model.route, function(req, res, next) {
    return req.model.loadPaginated(req.body, req, ErrorHandler(next, function(err, response) {
      return res.send(response);
    }));
  });
  server.get('/facts/:fact-type/settings', Factsettings_Model.route, function(req, res, next) {
    return req.model.load({
      _id: req.params['fact-type']
    }, ErrorHandler(next, function(err, found) {
      return res.send(this["export"]());
    }));
  });
  server.post('/facts/:fact-type/settings', Factsettings_Model.route, function(req, res, next) {
    req.body._id = req.params['fact-type'];
    return req.model.update({
      _id: req.body._id
    }, req.body, ErrorHandler(next, function(err, update) {
      return res.send({
        status: 'ok',
        statusText: 'The fact settings were updated.',
        settings: this["export"]()
      });
    }));
  });
  server.get('/facts/:fact-type/fact/:fact-id', Fact_Model.route, function(req, res, next) {
    return req.model.load({
      _id: req.params['fact-id']
    }, true, ErrorHandler(next, function() {
      return this.updateFields(function() {
        return res.send(this["export"]());
      });
    }));
  });
  server.get('/facts/:fact-type/fact_def/:fact-id', Fact_deferred_Model.route, function(req, res, next) {
    var _base, _ref;
    req.body["with"] = [].concat.call([], (_ref = req.body["with"]) != null ? _ref : {});
    if ((_base = req.body).map == null) {
      _base.map = false;
    }
    return req.model.load({
      _id: req.params['fact-id']
    }, true, ErrorHandler(next, function(err, found) {
      var _this = this;
      if (err || !found) {
        return res.notFound('fact');
      }
      return async.map(req.body["with"], this.data.get.bind(this.data), function() {
        if (!req.body.map) {
          return res.send(_this.data);
        }
        return _this.addShim(function() {
          var get, key, obj, path;
          obj = {};
          get = function(arg, next) {
            var key, path;
            key = arg[0], path = arg[1];
            return _this.data["eval"](path, function(err, result) {
              return next(null, obj[key] = result);
            });
          };
          return async.map((function() {
            var _ref1, _results;
            _ref1 = req.body.map;
            _results = [];
            for (key in _ref1) {
              path = _ref1[key];
              _results.push([key, path]);
            }
            return _results;
          })(), get, function() {
            return next(res.send(obj));
          });
        });
      });
    }));
  });
  server.post('/facts/:fact-type/fact/:fact-id', Fact_Model.route, function(req, res, next) {
    req.body._id = req.params['fact-id'];
    return req.model.update({
      _id: req.body._id
    }, req.body, ErrorHandler(next, function(err, updated) {
      return res.send({
        status: 'ok',
        statusText: 'The fact was ' + (updated && 'updated.' || 'created.'),
        fact: this["export"]()
      });
    }));
  });
  server.del('/facts/:fact-type', Fact_Model.route, function(req, res, next) {
    return req.model.removeFull(ErrorHandler(next, function() {
      return res.send({
        status: 'ok',
        statusText: 'All facts of this type have been deleted.'
      });
    }));
  });
  return server.del('/facts/:fact-type/fact/:fact-id', Fact_Model.route, function(req, res, next) {
    return req.model.remove({
      _id: req.params['fact-id']
    }, ErrorHandler(next, function(err, count) {
      return res.send({
        status: 'ok',
        statusText: 'The fact was deleted.',
        deleted: count | 0
      });
    }));
  });
};
